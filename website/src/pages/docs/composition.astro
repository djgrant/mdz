---
import DocsLayout from "../../layouts/DocsLayout.astro";
---

<DocsLayout title="Composition">
  <h1>Composition</h1>

  <p class="lead">
    Skills in MDZ compose through references and delegation, enabling complex
    behaviors from simple, validated components.
  </p>

  <h2>Skill Links</h2>

  <p>Reference another skill using a <strong>skill link</strong> (wiki-link style):</p>

  <pre><code class="mdz"><span class="zen-reference">[[skill-name]]</span></code></pre>

  <p>In prose:</p>

  <pre><code>Execute the task using <span class="zen-reference">[[orchestrate-map-reduce]]</span> methodology.</code></pre>

  <p>
    Tooling validates that referenced skills exist. You won't discover a missing
    dependency at runtime.
  </p>

  <h2>Section Links</h2>

  <h3>Within Current Skill</h3>

  <p>Use a <strong>section link</strong> to reference a section in the current document:</p>

  <pre><code class="mdz"><span class="zen-reference">[[#section-name]]</span></code></pre>

  <h3>In Another Skill</h3>

  <p>Combine skill and section in a single link:</p>

  <pre><code class="mdz"><span class="zen-reference">[[skill-name#section-name]]</span></code></pre>

  <h3>Section Names</h3>

  <p>Section names are derived from headings by:</p>

  <ol>
    <li>Converting to lowercase</li>
    <li>Replacing spaces with hyphens</li>
    <li>Removing special characters</li>
  </ol>

  <pre><code class="mdz"><span class="zen-heading">## Validate Prompt</span>
→ <span class="zen-reference">[[#validate-prompt]]</span>

<span class="zen-heading">## 2. Execute Phase</span>
→ <span class="zen-reference">[[#2-execute-phase]]</span></code></pre>

  <h2>Delegation with Parameters</h2>

  <p>Pass parameters when delegating to a skill using the <strong>with clause</strong>:</p>

  <pre><code class="mdz">Execute <span class="zen-reference">[[orchestrate-map-reduce]]</span> <span class="zen-keyword">WITH</span>:
  - <span class="zen-variable">$task</span> = <span class="zen-string">"Apply heuristic"</span>
  - <span class="zen-variable">$validator</span> = <span class="zen-reference">[[#validate-essence]]</span></code></pre>

  <p>
    Tooling validates that required parameters are provided and types match the
    skill's declared interface.
  </p>

  <h3>Inline Parameters</h3>

  <p>For simple cases:</p>

  <pre><code>Use <span class="zen-reference">[[#section]]</span> passing <span class="zen-variable">$current</span> and <span class="zen-variable">$next</span></code></pre>

  <h2>Dependency Declaration</h2>

  <p>Declare skill dependencies in frontmatter:</p>

  <pre><code class="mdz"><span class="zen-comment">---
name: my-skill
description: When orchestrating complex workflows
uses:
  - orchestrate
  - work-packages
  - scientific-method
---</span></code></pre>

  <h3>Benefits</h3>

  <ul>
    <li>Dependency graph visualization</li>
    <li>Circular dependency detection</li>
    <li>IDE autocomplete for available skills</li>
    <li>Documentation of relationships</li>
  </ul>

  <h2>Patterns</h2>

  <h3>Sub-Agent Delegation</h3>

  <pre><code>Delegate to sub-agent with <span class="zen-reference">[[#experiment-prompt]]</span>:
  - The experiment work package
  - Access to <span class="zen-reference">[[work-packages]]</span> skill</code></pre>

  <h3>Conditional Delegation</h3>

  <pre><code class="mdz"><span class="zen-keyword">IF</span> <span class="zen-variable">$result</span> = <span class="zen-string">"failure"</span> <span class="zen-keyword">THEN</span>:
  - Attempt recovery using <span class="zen-reference">[[#recovery-strategy]]</span>
<span class="zen-keyword">ELSE</span>:
  - Continue with <span class="zen-reference">[[#main-workflow]]</span></code></pre>

  <h3>Iterative Composition</h3>

  <pre><code class="mdz"><span class="zen-keyword">FOR EACH</span> <span class="zen-variable">$skill</span> <span class="zen-keyword">IN</span> <span class="zen-variable">$skills</span>:
  - Load <span class="zen-variable">$skill</span> source
  - Execute with <span class="zen-reference">[[orchestrate]]</span>
  - Collect results</code></pre>

  <h2>Reference Handling</h2>

  <p>
    By default, references stay as-is—the LLM interprets <code>[[skill]]</code>
    syntax directly. With optional preprocessing:
  </p>

  <ul>
    <li>
      <strong>Inlining</strong> — Referenced skill content embedded inline
    </li>
    <li>
      <strong>Section extraction</strong> — Only the referenced section included
    </li>
  </ul>

  <p>
    Both approaches are valid. Inlining reduces LLM load-time; leaving
    references keeps the prompt concise. Experiment to find what works best for
    your use case.
  </p>

  <h2>Best Practices</h2>

  <ul>
    <li>Declare all dependencies in frontmatter</li>
    <li>Create reusable prompt sections within skills</li>
    <li>Use descriptive section names</li>
    <li>Keep skills focused and composable</li>
    <li>Document expected parameters in Input sections</li>
  </ul>
</DocsLayout>
