---
import DocsLayout from '../../layouts/DocsLayout.astro';
---

<DocsLayout title="Higher-Order Skills">
  <h1>Higher-Order Skills</h1>
  
  <p class="lead">
    Skills that compose and orchestrate other skills—like higher-order functions, 
    but for agent workflows.
  </p>

  <h2>What are Higher-Order Skills?</h2>
  
  <p>
    A higher-order skill doesn't just perform a task—it orchestrates other skills 
    to accomplish complex, multi-step objectives. Just as higher-order functions 
    take functions as arguments and return functions, higher-order skills take 
    skills as dependencies and coordinate their execution.
  </p>
  
  <p>
    These skills typically:
  </p>
  
  <ul>
    <li>Declare dependencies on multiple skills via <code>uses:</code></li>
    <li>Define iteration or branching logic to coordinate execution</li>
    <li>Manage state across multiple sub-skill invocations</li>
    <li>Synthesize results from delegated work</li>
  </ul>

  <h2>Patterns</h2>

  <h3>Map-Reduce</h3>
  
  <p>
    Fan out work to multiple agents, collect results, and synthesize a final output:
  </p>
  
  <pre><code class="mdz"><span class="zen-keyword">FOR EACH</span> <span class="zen-variable">$item</span> <span class="zen-keyword">IN</span> <span class="zen-variable">$collection</span>:
  - Delegate to sub-agent <span class="zen-keyword">WITH</span> <span class="zen-reference">[[process-item]]</span>
  - Collect <span class="zen-variable">$result</span> into <span class="zen-variable">$results</span>

Synthesize <span class="zen-variable">$results</span> into final output</code></pre>

  <p>
    This pattern excels when work can be parallelized and results need aggregation.
  </p>

  <h3>Iteration with Hypothesis Testing</h3>
  
  <p>
    Loop until a condition is met, refining approach based on observations:
  </p>
  
  <pre><code class="mdz"><span class="zen-keyword">WHILE</span> <span class="zen-keyword">NOT</span> success <span class="zen-keyword">AND</span> <span class="zen-variable">$iteration</span> &lt; <span class="zen-variable">$maxIterations</span> <span class="zen-keyword">DO</span>:
  - Form hypothesis
  - Run experiment
  - Observe results
  - <span class="zen-keyword">IF</span> progress <span class="zen-keyword">THEN</span> refine <span class="zen-keyword">ELSE</span> pivot</code></pre>

  <p>
    This pattern is ideal for problems requiring exploration and adaptation.
  </p>

  <h3>Pipeline</h3>
  
  <p>
    Sequential skill chaining where output flows from one stage to the next:
  </p>
  
  <pre><code class="mdz"><span class="zen-variable">$stage1Result</span> = Execute <span class="zen-reference">[[skill-a]]</span> <span class="zen-keyword">WITH</span> <span class="zen-variable">$input</span>
<span class="zen-variable">$stage2Result</span> = Execute <span class="zen-reference">[[skill-b]]</span> <span class="zen-keyword">WITH</span> <span class="zen-variable">$stage1Result</span>
<span class="zen-variable">$final</span> = Execute <span class="zen-reference">[[skill-c]]</span> <span class="zen-keyword">WITH</span> <span class="zen-variable">$stage2Result</span></code></pre>

  <p>
    Use this when each step transforms data for the next stage.
  </p>

  <h2>Example: The Scientist</h2>
  
  <p>
    The <code>scientific-method.mdz</code> skill demonstrates a sophisticated higher-order 
    pattern for hypothesis-driven iteration. It orchestrates sub-agents to run 
    experiments and refine solutions based on observations.
  </p>

  <h3>Structure</h3>
  
  <pre><code class="mdz"><span class="zen-comment">---
name: scientific-method
description: When orchestrating hypothesis-driven iteration
uses:
  - work-packages
---</span></code></pre>

  <h3>State Persistence with Work Packages</h3>
  
  <p>
    The scientist uses <code>[[work-packages]]</code> to persist state across iterations:
  </p>
  
  <ul>
    <li>A master work package tracks overall progress and findings</li>
    <li>Each experiment gets its own work package at a computed path</li>
    <li>Results are recorded for later synthesis</li>
  </ul>
  
  <pre><code class="mdz"><span class="zen-variable">$workPackagePath</span> = <span class="zen-variable">$n</span> =&gt; `<span class="zen-semantic">/work package directory/</span>/wp-experiment-<span class="zen-variable">$n</span>.md`</code></pre>

  <h3>The WHILE Loop</h3>
  
  <p>
    The core iteration continues until diminishing returns or max iterations:
  </p>
  
  <pre><code class="mdz"><span class="zen-keyword">WHILE</span> <span class="zen-keyword">NOT</span> diminishing returns <span class="zen-keyword">AND</span> <span class="zen-variable">$iteration</span> &lt; <span class="zen-variable">$maxIterations</span> <span class="zen-keyword">DO</span>:
  
  #### Design Experiment
  Create experiment work package with success criteria
  
  #### Run Experiment
  Delegate to sub-agent with <span class="zen-reference">[[#experiment-prompt]]</span>
  
  #### Observe Results
  Extract <span class="zen-variable">$observations</span> and update master work package
  
  #### Evaluate
  <span class="zen-keyword">IF</span> <span class="zen-variable">$result</span> = "progress" <span class="zen-keyword">THEN</span>:
    - Commit changes, update hypothesis
  <span class="zen-keyword">ELSE</span>:
    - Revert if regression, revise hypothesis</code></pre>

  <h3>Result Accumulation</h3>
  
  <p>
    The skill supports two strategies via <code>$strategy</code>:
  </p>
  
  <ul>
    <li><strong>accumulate</strong>: Commit successful changes and build on them</li>
    <li><strong>independent</strong>: Run experiments independently, synthesize at the end</li>
  </ul>
  
  <p>
    The final conclusion synthesizes all findings, documenting what worked and what didn't.
  </p>

  <h2>Structure of a Higher-Order Skill</h2>
  
  <p>
    A typical higher-order skill follows this structure:
  </p>
  
  <pre><code class="mdz"><span class="zen-comment">---
name: orchestrator-skill
description: When coordinating multiple skills
uses:
  - skill-a
  - skill-b
  - work-packages
---</span>

<span class="zen-heading">## Types</span>

<span class="zen-type">$State</span>: <span class="zen-semantic">/context maintained across iterations/</span>
<span class="zen-type">$Result</span>: <span class="zen-semantic">/output from delegated work/</span>

<span class="zen-heading">## Input</span>

- <span class="zen-variable">$collection</span>: items to process
- <span class="zen-variable">$maxIterations</span>: <span class="zen-type">$Number</span> = 5

<span class="zen-heading">## Context</span>

- <span class="zen-variable">$results</span>: <span class="zen-type">$Result</span>[] = []
- <span class="zen-variable">$iteration</span> = 0

<span class="zen-heading">## Workflow</span>

<span class="zen-keyword">FOR EACH</span> <span class="zen-variable">$item</span> <span class="zen-keyword">IN</span> <span class="zen-variable">$collection</span>:
  - Delegate to <span class="zen-reference">[[skill-a]]</span> <span class="zen-keyword">WITH</span>:
    - <span class="zen-variable">$param</span> = <span class="zen-variable">$item</span>
  - Collect result

Synthesize <span class="zen-variable">$results</span> using <span class="zen-reference">[[skill-b]]</span></code></pre>

  <h2>Key Techniques</h2>
  
  <ul>
    <li><strong>Declare dependencies</strong>: List all orchestrated skills in <code>uses:</code></li>
    <li><strong>Define iteration variables</strong>: Track state in the Context section</li>
    <li><strong>Use work packages</strong>: Persist state for complex, multi-step workflows</li>
    <li><strong>Create sub-agent prompts</strong>: Define reusable prompt sections for delegation</li>
    <li><strong>Handle failure modes</strong>: Include branching logic for different outcomes</li>
  </ul>

  <h2>See Also</h2>
  
  <ul>
    <li><a href="/docs/composition">Composition</a> — Skill references and delegation</li>
    <li><a href="/docs/control-flow">Control Flow</a> — WHILE, FOR EACH, IF/THEN/ELSE</li>
    <li><a href="/examples">Examples</a> — Full implementations including scientific-method</li>
  </ul>
</DocsLayout>
