---
import DocsLayout from "../../layouts/DocsLayout.astro";
---

<DocsLayout title="Type System">
  <h1>Type System</h1>

  <p class="lead">
    Types in MDZ are contracts for tooling and semantic hints for LLMs—not
    runtime enforcement.
  </p>

  <h2>Philosophy</h2>

  <p>Unlike traditional programming languages, MDZ types are:</p>

  <ul>
    <li><strong>Descriptive</strong> — They document intent for humans</li>
    <li><strong>Interpretive</strong> — They guide LLM behavior</li>
    <li>
      <strong>Tooling-friendly</strong> — They enable validation and autocomplete
    </li>
    <li>
      <strong>Build-time checked</strong> — Contract compatibility verified before
      runtime
    </li>
  </ul>

  <h2>Types as Contracts</h2>

  <p>Types enable tooling to check that modules fit together correctly:</p>

  <pre><code><span class="zen-comment"># In skill A</span>
- <span class="zen-variable">$validator</span>: <span class="zen-type">$Task</span>

<span class="zen-comment"># In skill B (referencing A)</span>
Execute <span class="zen-reference">[[skill-a]]</span> <span class="zen-keyword">WITH</span>:
  - <span class="zen-variable">$validator</span> = 42  ← Error: <span class="zen-type">$Number</span> where <span class="zen-type">$Task</span> expected</code></pre>

  <p>
    This mismatch is caught at build time—before the LLM ever sees it. 
    Without MDZ, you'd discover it at runtime with a confused LLM.
  </p>

  <h2>Defining Types</h2>

  <h3>Semantic Types</h3>

  <p>Natural language descriptions that help LLMs understand values:</p>

  <pre><code><span class="zen-type">$Task</span>: any task that an agent can execute
<span class="zen-type">$Hypothesis</span>: a testable prediction about what will solve the problem
<span class="zen-type">$Observation</span>: data collected from running an experiment</code></pre>

  <h3>Enum Types</h3>

  <p>Constrained sets of string values using the <strong>union</strong> operator (<code>|</code>):</p>

  <pre><code><span class="zen-type">$Strategy</span>: <span class="zen-string">"fast"</span> | <span class="zen-string">"thorough"</span>
<span class="zen-type">$Result</span>: <span class="zen-string">"confirmed"</span> | <span class="zen-string">"refuted"</span> | <span class="zen-string">"inconclusive"</span>
<span class="zen-type">$Priority</span>: <span class="zen-string">"low"</span> | <span class="zen-string">"medium"</span> | <span class="zen-string">"high"</span> | <span class="zen-string">"critical"</span></code></pre>

  <h3>Tuple Types</h3>

  <p><strong>Tuples</strong> combine multiple types:</p>

  <pre><code><span class="zen-type">$TaskWithPriority</span>: (<span class="zen-type">$Task</span>, <span class="zen-type">$Priority</span>)
<span class="zen-type">$Transform</span>: (<span class="zen-type">$Task</span>, <span class="zen-type">$Strategy</span>)</code></pre>

  <h3>Array Types</h3>

  <p>Collections using the <strong>array suffix</strong> (<code>[]</code>):</p>

  <pre><code><span class="zen-type">$Tasks</span>: <span class="zen-type">$Task</span>[]
<span class="zen-type">$Transforms</span>: (<span class="zen-type">$Task</span>, <span class="zen-type">$Strategy</span>)[]</code></pre>

  <h3>Function Types</h3>

  <p><strong>Lambda expressions</strong> using the <strong>arrow</strong> operator (<code>=&gt;</code>):</p>

  <pre><code><span class="zen-type">$PathGenerator</span> = <span class="zen-variable">$n</span> =&gt; `output-&#123;<span class="zen-variable">$n</span>&#125;.md`
<span class="zen-type">$Formatter</span> = (<span class="zen-variable">$item</span>, <span class="zen-variable">$index</span>) =&gt; `&#123;<span class="zen-variable">$index</span>&#125;. &#123;<span class="zen-variable">$item</span>&#125;`</code></pre>

  <h2>Using Types</h2>

  <h3>Typed Declarations</h3>

  <p>Use the <strong>type annotation</strong> (<code>:</code>) to declare variable types:</p>

  <pre><code>- <span class="zen-variable">$task</span>: <span class="zen-type">$Task</span>                           <span class="zen-comment"># required parameter</span>
- <span class="zen-variable">$result</span>: <span class="zen-type">$Result</span>: <span class="zen-string">"pending"</span>           <span class="zen-comment"># typed declaration with default</span>
- <span class="zen-variable">$transforms</span>: (<span class="zen-type">$Task</span>, <span class="zen-type">$Strategy</span>)[]     <span class="zen-comment"># array of tuples</span></code></pre>

  <h3>What Tooling Checks</h3>

  <p>The MDZ validator performs static analysis on types:</p>

  <ul>
    <li>
      <strong>Undefined types</strong> — Using <code>$Foo</code> without defining
      it
    </li>
    <li>
      <strong>Contract mismatches</strong> — Passing wrong type across skill boundaries
    </li>
    <li>
      <strong>Typos</strong> — <code>$Numbr</code> flagged with "did you mean <code
        >$Number</code
      >?"
    </li>
  </ul>

  <p>
    The LLM sees the types as you wrote them—<code>$Task</code> stays <code
      >$Task</code
    >. Types are signals to both tooling and the LLM, not something that gets
    transformed.
  </p>

  <h2>Built-in Types</h2>

  <p>These types are implicitly available:</p>

  <ul>
    <li><code>$String</code> — text content</li>
    <li><code>$Number</code> — numeric value</li>
    <li><code>$Boolean</code> — true or false</li>
    <li><code>$FilePath</code> — a file system path</li>
  </ul>

  <h2>Best Practices</h2>

  <ul>
    <li>Use descriptive names: <code>$Hypothesis</code> not <code>$H</code></li>
    <li>
      Write clear descriptions: think "what would help an LLM understand this?"
    </li>
    <li>Use enums for fixed sets of options</li>
    <li>
      Define types at the top of your skill in a <code>## Types</code> section
    </li>
  </ul>
</DocsLayout>
