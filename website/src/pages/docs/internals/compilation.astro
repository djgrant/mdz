---
import DocsLayout from '../../../layouts/DocsLayout.astro';
---

<DocsLayout title="Compilation">
  <h1>Compilation</h1>

  <p class="lead">
    The MDZ compiler is validator-first: it validates without transforming the source. This page covers the compilation pipeline, metadata extraction, skill registry, and dependency graph construction.
  </p>

  <h2>Source = Output Principle</h2>

  <p>
    <strong>The LLM sees exactly what you write.</strong> No code generation, no transpilation. The compiler:
  </p>

  <ul>
    <li>Parses the source into AST</li>
    <li>Extracts metadata and validates</li>
    <li>Returns the original source unchanged</li>
    <li>Provides diagnostics and dependency information</li>
  </ul>

  <h2>Metadata Extraction</h2>

  <p>
    The compiler extracts structured information for tooling: document metadata, type definitions, variable declarations, skill/section references, and section anchors.
  </p>

  <p>
    Extracted metadata includes:
  </p>

  <ul>
    <li><strong>Frontmatter</strong> — name, description, uses array</li>
    <li><strong>Types</strong> — All type definitions with their expressions</li>
    <li><strong>Variables</strong> — All variable declarations with types and values</li>
    <li><strong>References</strong> — Skill and section references throughout the document</li>
    <li><strong>Sections</strong> — Section headings with their anchor IDs</li>
  </ul>

  <h2>Skill Registry</h2>

  <p>
    For cross-skill validation, the compiler uses a skill registry that provides access to other skills' ASTs and content. The registry enables validating references, checking type consistency, and providing IDE completions.
  </p>

  <p>
    Registry operations:
  </p>

  <ul>
    <li><strong>register(skill)</strong> — Add a skill to the registry</li>
    <li><strong>get(name)</strong> — Retrieve a skill by name</li>
    <li><strong>has(name)</strong> — Check if a skill exists</li>
    <li><strong>getSections(name)</strong> — Get available sections for a skill</li>
  </ul>

  <h2>Dependency Graph Construction</h2>

  <p>
    Dependencies are extracted from multiple sources:
  </p>

  <ul>
    <li><strong>uses:</strong> — Explicit skill dependencies in frontmatter</li>
    <li><strong>references:</strong> — Inline <code>[[skill]]</code> and <code>[[skill#section]]</code> references</li>
  </ul>

  <p>
    The compiler builds a dependency graph showing:
  </p>

  <ul>
    <li><strong>Nodes</strong> — Skills this document depends on</li>
    <li><strong>Edges</strong> — Relationship type (uses, reference)</li>
    <li><strong>Cycles</strong> — Circular dependency chains (if any)</li>
  </ul>

  <h3>Cycle Detection Algorithm</h3>

  <p>
    Uses DFS with three states: unvisited, visiting, visited. When encountering a node already in 'visiting' state, a cycle is detected.
  </p>

  <pre><code class="language-typescript">{`function detectCycles(graph: DependencyGraph): string[][] {
  const cycles: string[][] = [];
  const state = new Map<string, 'unvisited' | 'visiting' | 'visited'>();
  const path: string[] = [];

  function visit(node: string) {
    if (state.get(node) === 'visiting') {
      // Found a cycle
      const cycleStart = path.indexOf(node);
      cycles.push([...path.slice(cycleStart), node]);
      return;
    }
    if (state.get(node) === 'visited') return;

    state.set(node, 'visiting');
    path.push(node);

    for (const dep of graph.getDependencies(node)) {
      visit(dep);
    }

    path.pop();
    state.set(node, 'visited');
  }

  for (const node of graph.nodes) {
    visit(node);
  }
  return cycles;
}`}</code></pre>

  <h3>Graph Visualization</h3>

  <p>
    The <code>mdz graph</code> command generates visualization data that can be rendered using various tools. The output includes:
  </p>

  <ul>
    <li>DOT format for Graphviz</li>
    <li>JSON format for custom renderers</li>
    <li>Mermaid format for documentation</li>
  </ul>

  <h2>Diagnostic System</h2>

  <p>
    Validation produces structured diagnostics with severity levels (error, warning, info), error codes, messages, and source locations.
  </p>

  <pre><code class="language-typescript">{`interface Diagnostic {
  severity: 'error' | 'warning' | 'info';
  code: string;
  message: string;
  span: Span;
  suggestions?: string[];
}`}</code></pre>

  <p>
    Common error codes include:
  </p>

  <ul>
    <li><strong>E007</strong> — Undefined variable reference</li>
    <li><strong>E008</strong> — Undefined type reference</li>
    <li><strong>E009</strong> — Undefined skill reference</li>
    <li><strong>E010</strong> — Undefined section reference</li>
    <li><strong>E999</strong> — Circular dependency detected</li>
  </ul>

  <h2>LSP Integration</h2>

  <p>
    The Language Server Protocol implementation provides IDE features for MDZ files.
  </p>

  <h3>Document State Management</h3>

  <p>
    The LSP server maintains state for each open document, including the parsed AST, extracted types and variables, references, and semantic markers for fast IDE operations.
  </p>

  <h3>Go-to-Definition</h3>

  <p>
    Supports navigation to:
  </p>

  <ul>
    <li>Variable declarations from usage sites</li>
    <li>Type definitions from references</li>
    <li>Skill definitions from <code>[[skill]]</code> references</li>
    <li>Section anchors from <code>[[#section]]</code> references</li>
  </ul>

  <h3>Hover Information</h3>

  <p>
    Provides contextual information on hover:
  </p>

  <ul>
    <li>Type definitions and their structure</li>
    <li>Variable types and lambda status</li>
    <li>Skill descriptions from frontmatter</li>
    <li>Reference targets</li>
  </ul>

  <h3>Autocompletion</h3>

  <p>
    Context-aware completions for:
  </p>

  <ul>
    <li><strong>Skills</strong> — After <code>[[</code>, shows available skills</li>
    <li><strong>Variables/Types</strong> — After <code>$</code>, shows defined names</li>
    <li><strong>Semantic markers</strong> — After semantic marker syntax, suggests common patterns</li>
    <li><strong>Keywords</strong> — At line start, suggests control flow constructs</li>
  </ul>

  <h3>Diagnostics</h3>

  <p>
    Real-time validation in the editor:
  </p>

  <ul>
    <li>Parse errors from the parser</li>
    <li>Undefined skill references</li>
    <li>Type and scope issues</li>
  </ul>

  <h3>Document Symbols</h3>

  <p>
    Provides outline/symbol view:
  </p>

  <ul>
    <li>Sections as top-level symbols</li>
    <li>Types and variables as children</li>
    <li>Control flow structures</li>
  </ul>

  <h3>Skill Registry Integration</h3>

  <p>
    The LSP maintains a workspace skill registry:
  </p>

  <ul>
    <li>Auto-registers skills from open documents</li>
    <li>Provides cross-file completions</li>
    <li>Validates cross-skill references</li>
  </ul>
</DocsLayout>
