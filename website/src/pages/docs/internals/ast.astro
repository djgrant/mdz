---
import DocsLayout from '../../../layouts/DocsLayout.astro';
---

<DocsLayout title="AST Structure">
  <h1>AST Structure</h1>

  <p class="lead">
    MDZ uses a two-phase parsing approach: lexical analysis followed by recursive descent parsing. This page covers the lexer, parser, and AST node types.
  </p>

  <h2>Lexical Analysis</h2>

  <p>
    The <strong>lexer</strong> tokenizes source text into a stream of tokens. It handles:
  </p>

  <ul>
    <li>Indentation-based block structure</li>
    <li>Markdown constructs (headings, lists, code blocks)</li>
    <li>MDZ-specific tokens (variables, references, semantic markers)</li>
    <li>Control flow keywords (FOR, WHILE, IF, etc.)</li>
  </ul>

  <h3>Lexer Token Examples</h3>

  <p>
    Here's how the lexer tokenizes a simple MDZ snippet:
  </p>

  <pre><code class="mdz">---
name: example
---

## Types

$User: /person with name and email/</code></pre>

  <p>
    This produces the following token stream (simplified):
  </p>

  <pre><code class="language-json">[FRONTMATTER_START '---'], [LOWER_IDENT 'name'], [COLON ':' ], 
[LOWER_IDENT 'example'], [FRONTMATTER_END '---'], [HEADING '## Types'],
[TYPE_IDENT '$User'], [COLON ':'], [TEXT 'person with name and email'], [EOF]</code></pre>

  <h3>Indentation Stack Algorithm</h3>

  <p>
    MDZ uses an indentation stack to handle Python-style block structure. The algorithm maintains a stack of indentation levels:
  </p>

  <ul>
    <li>Start with stack = [0]</li>
    <li>For each line, measure leading whitespace</li>
    <li>If indent > current level: push new level, emit INDENT</li>
    <li>If indent &lt; current level: pop levels until match, emit DEDENT</li>
    <li>Handle mixed tabs/spaces (tabs = 2 spaces)</li>
  </ul>

  <p>
    <strong>Data structures:</strong> Simple array stack for indent levels, position tracking for error reporting.
  </p>

  <p>
    <strong>Edge cases handled:</strong> Mixed tabs/spaces (tabs count as 2 spaces), empty lines (ignored), and inconsistent indentation (reported as errors).
  </p>

  <h2>Recursive Descent Parser</h2>

  <p>
    The <strong>parser</strong> builds an Abstract Syntax Tree (AST) using recursive descent with the following grammar productions:
  </p>

  <h3>Grammar Productions</h3>

  <pre><code class="language-ebnf">Document ::= Frontmatter? Section* EOF

Frontmatter ::= FRONTMATTER_START FrontmatterContent* FRONTMATTER_END

Section ::= HEADING Block* (INDENT Block+ DEDENT)?

Block ::= TypeDefinition | VariableDeclaration | ControlFlow | Delegation | Prose

TypeDefinition ::= TYPE_IDENT ASSIGN TypeExpr

VariableDeclaration ::= DOLLAR_IDENT (COLON TypeReference)? (ASSIGN Expression)?

ControlFlow ::= ForEach | While | If | Break | Continue

ForEach ::= FOR EACH Pattern IN Expression COLON NEWLINE INDENT Block+ DEDENT

Expression ::= Literal | Reference | BinaryOp | FunctionCall | TemplateLiteral</code></pre>

  <p>
    The parser maintains state for:
  </p>

  <ul>
    <li><strong>Loop depth</strong> — Counter for BREAK/CONTINUE validation (must be inside loops)</li>
    <li><strong>Parse errors</strong> — Recoverable syntax issues collected in AST</li>
    <li><strong>Source spans</strong> — Position tracking for error reporting and IDE features</li>
  </ul>

  <h3>Error Recovery Strategy</h3>

  <p>
    The parser uses panic-mode error recovery: when a syntax error is encountered, it skips tokens until it finds a synchronization point (like NEWLINE or DEDENT), then continues parsing. This allows reporting multiple errors in a single pass rather than stopping at the first error.
  </p>

  <h2>AST Node Types</h2>

  <p>
    The AST is a complete representation of the parsed document, with full type safety and source location tracking.
  </p>

  <h3>Core Types</h3>

  <p>
    Every AST node extends <code>BaseNode</code> with a <code>kind</code> discriminant and <code>span</code> for source location tracking.
  </p>

  <p>
    The core interfaces are:
  </p>

  <ul>
    <li><code>frontmatter</code> — Optional metadata (name, description)</li>
    <li><code>sections</code> — Array of heading-based content sections</li>
    <li><code>errors</code> — Parse errors encountered during parsing</li>
  </ul>

  <h3>Document Structure</h3>

  <p>
    The root is a <code>Document</code> containing frontmatter and sections, with parse errors collected during parsing.
  </p>

  <p>
    Key document properties:
  </p>

  <ul>
    <li>Frontmatter (name, description)</li>
    <li>Type definitions (<code>$Type: ...</code>)</li>
    <li>Variable declarations (<code>$var: $Type = value</code>)</li>
    <li>Control flow (FOR EACH, WHILE, IF/THEN/ELSE)</li>
    <li>Composition keywords (USE, EXECUTE, DELEGATE, GOTO)</li>
    <li>Links (<code>~/skill/name</code>, <code>~/agent/name</code>)</li>
    <li>Anchors (<code>#section</code>)</li>
    <li>Semantic markers (<code>/content/</code>, <code>$/name/</code>)</li>
  </ul>

  <h3>AST Construction Example</h3>

  <p>
    For this MDZ input:
  </p>

  <pre><code class="mdz">---
name: calculator
---

## Input

- $x: Number
- $y: Number</code></pre>

  <p>
    The parser produces this AST structure (simplified):
  </p>

  <ul>
    <li><strong>Document</strong> root with frontmatter and sections</li>
    <li><strong>Frontmatter</strong> containing metadata (name: calculator)</li>
    <li><strong>Section</strong> for "Input" with level 2 heading</li>
    <li><strong>List</strong> containing two VariableDeclaration nodes</li>
    <li><strong>VariableDeclarations</strong> for $x and $y with Number type annotations</li>
  </ul>

  <h3>Block Types</h3>

  <p>
    Blocks represent the different constructs that can appear in sections: type definitions, variable declarations, control flow statements (FOR EACH, WHILE, IF), delegation, and prose content (paragraphs, code blocks, lists).
  </p>

  <h3>Expression Types</h3>

  <p>
    Expressions handle values and computations: literals, variable references, function calls, skill/section references, semantic markers, and binary operations.
  </p>

  <pre><code class="language-typescript">type Expression =
  | StringLiteral | NumberLiteral | BooleanLiteral
  | VariableReference | FunctionCall | SkillReference
  | BinaryExpression | TemplateLiteral | SemanticMarker;
</code></pre>

  <h3>Type System</h3>

  <p>
    MDZ's type system supports semantic types (descriptive), enums, compound types (tuples), arrays, functions, and type references.
  </p>

  <p>
    Type expressions include:
  </p>

  <ul>
    <li><strong>SemanticType</strong> — Descriptive types like "user identifier" or "email address"</li>
    <li><strong>EnumType</strong> — Fixed set of values like "admin | user | guest"</li>
    <li><strong>CompoundType</strong> — Tuples like (String, Number)</li>
    <li><strong>ArrayType</strong> — Collections like String[]</li>
    <li><strong>FunctionType</strong> — Function signatures like (x, y) => Number</li>
    <li><strong>TypeReference</strong> — References to defined types like $User</li>
  </ul>

  <h3>Control Flow</h3>

  <p>
    Control structures are represented as executable blocks: FOR EACH loops (sequential and parallel), WHILE loops, IF/THEN/ELSE statements, and BREAK/CONTINUE statements for loop control.
  </p>

  <p>
    Loop statements include:
  </p>

  <ul>
    <li><strong>ForEachStatement</strong> — Sequential iteration over collections</li>
    <li><strong>ParallelForEachStatement</strong> — Parallel iteration with optional merge strategies (collect/first/last)</li>
    <li><strong>WhileStatement</strong> — Conditional loops</li>
    <li><strong>IfStatement</strong> — Conditional execution with optional else blocks</li>
    <li><strong>BreakStatement/ContinueStatement</strong> — Loop control flow</li>
  </ul>
</DocsLayout>
