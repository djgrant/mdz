---
import DocsLayout from '../../layouts/DocsLayout.astro';
---

<DocsLayout title="API">
  <h1>Programmatic API</h1>
  
  <p class="lead">
    Use MDZ programmatically in your TypeScript or JavaScript projects.
  </p>

  <h2>Installation</h2>
  
  <pre><code class="language-bash">npm install zenmarkdown</code></pre>

  <h2>Parsing</h2>
  
  <pre><code class="language-typescript">import &#123; parse &#125; from 'zenmarkdown';

const source = `<span class="zen-comment">---
name: my-skill
description: When you need to do something
---</span>

<span class="zen-heading">## Workflow</span>

1. Do the thing
`;

const ast = parse(source);

console.log(ast.frontmatter?.name);  // "my-skill"
console.log(ast.sections.length);    // 1</code></pre>

  <h2>Compiling</h2>
  
  <p>
    The primary use case: validate that a skill is correct before the LLM sees it.
  </p>
  
  <pre><code class="language-typescript">import &#123; compile &#125; from 'zenmarkdown';

const result = compile(source);

// Source is unchanged (no transformation)
console.log(result.output);  // === source

// Access validation results
for (const diag of result.diagnostics) &#123;
  const prefix = diag.severity === 'error' ? '✗' : '⚠';
  console.log(`$&#123;prefix&#125; [$&#123;diag.code&#125;] $&#123;diag.message&#125;`);
&#125;

// Access extracted metadata
console.log(result.metadata.types);
console.log(result.metadata.variables);
console.log(result.metadata.references);

// Access dependency graph
console.log(result.dependencies.nodes);
console.log(result.dependencies.edges);</code></pre>

  <h3>Compile Options</h3>
  
  <pre><code class="language-typescript">interface CompileOptions &#123;
  // Validate type references
  validateTypes?: boolean;
  
  // Validate variable scope
  validateScope?: boolean;
  
  // Validate skill/section references
  validateReferences?: boolean;
  
  // Include validation header comment
  includeHeader?: boolean;
  
  // Generate source map
  generateSourceMap?: boolean;
&#125;</code></pre>

  <h2>AST Types</h2>
  
  <pre><code class="language-typescript">import * as AST from 'zenmarkdown/ast';

// Document structure
interface Document &#123;
  kind: 'Document';
  frontmatter: Frontmatter | null;
  sections: Section[];
  errors: ParseError[];
  span: Span;
&#125;

// Section
interface Section &#123;
  kind: 'Section';
  level: number;
  title: string;
  anchor: string;
  content: Block[];
  span: Span;
&#125;</code></pre>

  <h2>Skill Registry</h2>
  
  <p>Create a registry for reference resolution:</p>
  
  <pre><code class="language-typescript">import &#123; compile, createRegistry &#125; from 'zenmarkdown';

const registry = createRegistry(&#123;
  'helper-skill': helperSource,
  'another-skill': anotherSource,
&#125;);

// Compile with registry for reference checking
const result = compile(source, &#123;
  validateReferences: true,
&#125;);</code></pre>

  <h2>Tokenizer</h2>
  
  <pre><code class="language-typescript">import &#123; tokenize &#125; from 'zenmarkdown';

const tokens = tokenize(source);
for (const token of tokens) &#123;
  console.log(token.type, token.value);
&#125;</code></pre>

  <h2>Dependency Graph</h2>
  
  <pre><code class="language-typescript">import &#123; buildFullDependencyGraph, createRegistry &#125; from 'zenmarkdown';

const registry = createRegistry(&#123;
  'skill-a': sourceA,
  'skill-b': sourceB,
&#125;);

const graph = buildFullDependencyGraph(registry);

// Graph contains all nodes and edges
console.log(graph.nodes);  // ['skill-a', 'skill-b', ...]
console.log(graph.edges);  // [&#123; source: 'skill-a', target: 'skill-b', type: 'uses' &#125;, ...]</code></pre>
</DocsLayout>
