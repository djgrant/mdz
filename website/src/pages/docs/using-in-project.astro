---
import DocsLayout from '../../layouts/DocsLayout.astro';
---

<DocsLayout title="Using MDZ in Your Project">
  <h1>Using MDZ in Your Project</h1>

   <p class="lead">
     Bridge the gap from playground examples to real-world adoption. Learn how to structure, validate, and integrate MDZ skills into your agent workflows.
   </p>

   <h2>Installation</h2>

   <p>
     Install the MDZ CLI globally to validate and work with skills:
   </p>

   <pre><code class="language-bash">npm install -g @zenmarkdown/cli</code></pre>

   <p>
     Verify installation:
   </p>

   <pre><code class="language-bash">mdz --version
# mdz 0.3.0</code></pre>

   <h2>Workflow Overview</h2>

  <p>
    Using MDZ in a project follows three core steps:
  </p>

   <ol>
     <li><strong>Write Skills</strong> - Author reusable MDZ skills for specific tasks</li>
     <li><strong>Validate</strong> - Check syntax, types, and references before runtime</li>
     <li><strong>Integrate</strong> - Use validated skills with agents and LLMs</li>
   </ol>

   <h2>Step-by-Step Tutorial</h2>

   <p>
     Follow this tutorial to create and use your first MDZ skill in a project.
   </p>

   <h3>1. Set Up Your Project</h3>

   <p>
     Create a new directory for your project and initialize it:
   </p>

   <pre><code class="language-bash">mkdir my-agent-project
cd my-agent-project
mkdir skills</code></pre>

   <h3>2. Create Your First Skill</h3>

   <p>
     Create <code>skills/task-processor.mdz</code> with this content (see <a href="/docs/syntax">syntax reference</a> for details):
   </p>

   <pre><code class="mdz">---
name: task-processor
description: When processing tasks with validation and error handling
---

## Types

$Task: /a unit of work with inputs and expected outputs/
$Result: /successful completion or error details/

## Input

$task: $Task

## Context

$attempts = 0
$maxAttempts = 3

## Workflow

1. Validate $task inputs and requirements
2. WHILE $attempts &lt; $maxAttempts DO
   Execute $task
   IF /execution succeeded/ THEN
     Return success result
   ELSE
     Increment $attempts
     Log error and retry strategy
   END
END
3. Return failure result with collected errors

## Error Handling

Handle common failure modes.
Invalid inputs.
Resource unavailability.
Timeout conditions.</code></pre>

   <h3>3. Validate Your Skill</h3>

   <p>
     Validate the skill for syntax and type errors:
   </p>

   <pre><code class="language-bash">mdz check skills/task-processor.mdz
# ✓ skills/task-processor.mdz is valid
#
#   Types: 2
#   Variables: 3
#   Dependencies: 0</code></pre>

   <p>
     If there are errors, fix them and re-run the check.
   </p>

   <h3>4. Compile the Skill</h3>

   <p>
     Compile the skill to generate metadata and validate thoroughly:
   </p>

   <pre><code class="language-bash">mdz compile skills/task-processor.mdz
# Outputs the compiled skill with validation header</code></pre>

   <p>
     Save the compiled output for use:
   </p>

   <pre><code class="language-bash">mdz compile skills/task-processor.mdz -o skills/task-processor.compiled.mdz</code></pre>

   <h3>5. Use the Skill with an LLM</h3>

   <p>
     Copy the workflow section and use it in your LLM prompts. For example, in Claude Desktop:
   </p>

   <pre><code class="mdz">You are a task processor. Follow this process:

## Types
$Task: /a unit of work with inputs and expected outputs/
$Result: /successful completion or error details/

## Input
$task: $Task

## Context
$attempts = 0
$maxAttempts = 3

## Workflow
1. Validate $task inputs and requirements
2. WHILE $attempts &lt; $maxAttempts DO
   Execute $task
   IF /execution succeeded/ THEN
     Return success result
   ELSE
     Increment $attempts
     Log error and retry strategy
   END
END
3. Return failure result with collected errors

## Error Handling
Handle common failure modes.
Invalid inputs.
Resource unavailability.
Timeout conditions.

Task to process: [PASTE YOUR TASK HERE]</code></pre>

   <h2>Project Structure</h2>

  <p>
    Organize your skills in a dedicated directory structure for maintainability:
  </p>

   <pre><code class="language-text">your-project/
├── skills/
│   ├── core/           # Fundamental skills
│   │   ├── reasoning.mdz
│   │   └── planning.mdz
│   ├── domain/         # Domain-specific skills
│   │   ├── code-review.mdz
│   │   └── testing.mdz
│   └── orchestration/  # Multi-skill workflows
│       └── project-manager.mdz
├── agents/
│   └── my-agent.ts     # Agent that uses skills
└── package.json</code></pre>

   <p>
     Skills are loaded by referencing their file paths. For programmatic integration, you can implement your own skill discovery logic.
   </p>

  <h2>Writing and Validating Skills</h2>

  <p>
    Create skills for common patterns in your project:
  </p>

  <pre><code class="mdz"><span class="zen-comment">---
name: code-review
description: When reviewing code changes for quality and correctness
---</span>

<span class="zen-heading">## Types</span>

<span class="zen-type">$CodeChange</span>: <span class="zen-semantic">/a set of file modifications with context/</span>
<span class="zen-type">$ReviewFocus</span>: <span class="zen-string">"security"</span> | <span class="zen-string">"performance"</span> | <span class="zen-string">"maintainability"</span> | <span class="zen-string">"correctness"</span>
<span class="zen-type">$Issue</span>: <span class="zen-semantic">/identified problem with severity and location/</span>

<span class="zen-heading">## Input</span>

<span class="zen-variable">$changes</span>: <span class="zen-type">$CodeChange</span>
<span class="zen-variable">$focus</span>: <span class="zen-type">$ReviewFocus</span>[] = ["correctness", "maintainability"]

<span class="zen-heading">## Context</span>

<span class="zen-variable">$issues</span>: <span class="zen-type">$Issue</span>[] = []

<span class="zen-heading">## Workflow</span>

1. Analyze <span class="zen-variable">$changes</span> for patterns and potential issues
2. <span class="zen-keyword">FOR</span> <span class="zen-variable">$area</span> <span class="zen-keyword">IN</span> <span class="zen-variable">$focus</span>
   Apply focused review for <span class="zen-variable">$area</span>
   Add identified issues to <span class="zen-variable">$issues</span>
   <span class="zen-keyword">END</span>
3. <span class="zen-keyword">USE</span> <span class="zen-reference">~/skill/reasoning</span> <span class="zen-keyword">TO</span> <span class="zen-semantic">/generate summary/</span></code></pre>

   <p>
     Validate your skills to catch issues early:
   </p>

   <pre><code class="language-bash">cd skills
mdz check code-review.mdz
mdz check domain/*.mdz  # Validate all domain skills</code></pre>

   <p>
     For more detailed validation and metadata generation, use <code>compile</code>:
   </p>

   <pre><code class="language-bash">mdz compile code-review.mdz --verbose  # Show validation summary
mdz compile code-review.mdz --metadata  # Generate metadata JSON</code></pre>

   <p>
     Analyze dependencies between skills:
   </p>

   <pre><code class="language-bash">mdz graph code-review.mdz --mermaid  # Output dependency graph</code></pre>

   <p>
     Parse skills to AST for programmatic use:
   </p>

   <pre><code class="language-bash">mdz parse code-review.mdz > code-review.ast.json</code></pre>

  <h2>Integration with Tools</h2>

  <h3>Claude Desktop</h3>

  <p>
    Use MDZ skills by copying their workflow sections into Claude prompts:
  </p>

  <pre><code class="mdz">You are a senior developer conducting a code review. Follow this process:

## Types
$CodeChange: /a set of file modifications with context/
$ReviewFocus: "security" | "performance" | "maintainability" | "correctness"
$Issue: /identified problem with severity and location/

## Input
$changes: $CodeChange (provided below)
$focus: $ReviewFocus[] = ["correctness", "maintainability"]

## Workflow
1. Analyze $changes for patterns and potential issues
2. FOR $area IN $focus
   Apply focused review for $area
   Document identified issues
END
3. Generate review summary with prioritized recommendations

Code changes to review:
[PASTE YOUR CODE CHANGES HERE]</code></pre>

   <h3>Custom Agent Frameworks</h3>

   <p>
     For programmatic integration, install the core library:
   </p>

   <pre><code class="language-bash">npm install @zenmarkdown/core</code></pre>

   <p>
     Use the <code>compile</code> function to validate and process skills. See <a href="/docs/api">API docs</a> for complete integration guide.
   </p>



  <h2>Copy-Paste Starting Point</h2>

  <p>
    Use this template to create your first project skill:
  </p>

  <pre><code class="mdz"><span class="zen-comment">---
name: task-processor
description: When processing tasks with validation and error handling
---</span>

<span class="zen-heading">## Types</span>

<span class="zen-type">$Task</span>: <span class="zen-semantic">/a unit of work with inputs and expected outputs/</span>
<span class="zen-type">$Result</span>: <span class="zen-semantic">/successful completion or error details/</span>

<span class="zen-heading">## Input</span>

<span class="zen-variable">$task</span>: <span class="zen-type">$Task</span>

<span class="zen-heading">## Context</span>

<span class="zen-variable">$attempts</span> = 0
<span class="zen-variable">$maxAttempts</span> = 3

<span class="zen-heading">## Workflow</span>

1. Validate <span class="zen-variable">$task</span> inputs and requirements
2. WHILE <span class="zen-variable">$attempts</span> &lt; <span class="zen-variable">$maxAttempts</span> DO
   Execute <span class="zen-variable">$task</span>
   IF <span class="zen-semantic">/execution succeeded/</span> THEN
     Return success result
   ELSE
     Increment <span class="zen-variable">$attempts</span>
     Log error and retry strategy
   <span class="zen-keyword">END</span>
<span class="zen-keyword">END</span>
3. Return failure result with collected errors

<span class="zen-heading">## Error Handling</span>

Handle common failure modes:
Invalid inputs.
Resource unavailability.
Timeout conditions.</code></pre>

   <h2>Best Practices</h2>

   <ul>
     <li><strong>Validate Early</strong> - Run <code>mdz check</code> in CI/CD pipelines</li>
     <li><strong>Skill Composition</strong> - Build complex workflows from simpler skills using links</li>
     <li><strong>Type Contracts</strong> - Define clear input/output types for reliability</li>
     <li><strong>Version Control</strong> - Track skill evolution alongside code changes</li>
     <li><strong>Testing</strong> - Test skills with representative inputs and edge cases</li>
   </ul>

   <h3>CI/CD Integration Example</h3>

   <p>
     Add to your <code>.github/workflows/ci.yml</code>:
   </p>

   <pre><code class="language-yaml">name: Validate MDZ Skills
on: [push, pull_request]
jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '20'
      - run: npm install -g @zenmarkdown/cli
      - run: mdz check skills/**/*.mdz</code></pre>

   <h3>Testing Skills</h3>

   <p>
     Test skills by validating with the CLI and checking for errors:
   </p>

   <pre><code class="language-bash"># Test validation
mdz check skills/task-processor.mdz

# Test compilation with verbose output
mdz compile skills/task-processor.mdz --verbose</code></pre>

  <h2>Next Steps</h2>

  <ul>
    <li><a href="/docs/composition">Skill Composition</a> - Learn to combine skills effectively</li>
    <li><a href="/docs/api">API Reference</a> - Programmatic skill integration</li>
     <li><a href="/examples">Examples</a> - Real-world skill implementations</li>
  </ul>
</DocsLayout>
