---
import DocsLayout from '../../layouts/DocsLayout.astro';
---

<DocsLayout title="Core Concepts">
  <h1>Core Concepts</h1>
  
  <p class="lead">
    Understanding the fundamental ideas behind MDZ.
  </p>

  <h2>The LLM is the Runtime</h2>
  
  <p>
    This is MDZ's core assumption: the LLM is a capable machine that reads skills, 
    interprets control flow, makes tool calls, and executes what the document says. 
    There is no separate orchestration layer—the LLM handles execution.
  </p>
  
  <p>
    MDZ provides the authoring format and validation tooling. The LLM + your agent 
    framework handles the actual execution.
  </p>

  <h2>What Makes an LLM Language Different</h2>
  
  <p>
    Traditional programming languages catch typos and semicolons. An LLM language is 
    less about syntactic correctness—the LLM can interpret messy input. Instead, it's 
    about <strong>structural and systematic correctness</strong>:
  </p>
  
  <ul>
    <li>Do all linked files actually exist?</li>
    <li>Are there circular dependencies that would cause infinite loops?</li>
    <li>Do types match across skill boundaries?</li>
    <li>Is the overall system coherent?</li>
  </ul>
  
  <p>
    A confused LLM hitting a broken <code>~/skill/nonexistent</code> at runtime wastes tokens and time. 
    MDZ catches these issues at build time, before the LLM ever sees the skill.
  </p>

  <h2>How it Works Under the Hood</h2>
  
  <p>
    MDZ uses a <strong>validator-first architecture</strong>. When you run <code>mdz check</code> 
    or <code>mdz compile</code>, here's what happens:
  </p>
  
  <h3>1. Parsing</h3>
  <p>
    The source is parsed into an Abstract Syntax Tree (AST). The parser recognizes:
  </p>
  <ul>
    <li>Frontmatter (name, description)</li>
    <li>Type definitions (<code>$Type: ...</code>)</li>
    <li>Variable declarations (<code>$var: $Type = value</code>)</li>
    <li>Control flow (FOR EACH, WHILE, IF/THEN/ELSE)</li>
    <li>Links (<code>~/skill/name</code>, <code>~/agent/name</code>)</li>
    <li>Anchors (<code>#section</code>)</li>
    <li>Semantic markers (<code>/content/</code>, <code>$/name/</code>)</li>
  </ul>

  <h3>2. Metadata Extraction</h3>
  <p>
    The compiler extracts structured metadata from the AST:
  </p>
  <ul>
    <li>All type definitions and their schemas</li>
    <li>All variable declarations with their types</li>
    <li>All links and anchor references</li>
    <li>Section anchors for cross-referencing</li>
  </ul>

  <h3>3. Dependency Graph</h3>
  <p>
    A dependency graph is built from inline links. Dependencies are 
    <strong>inferred automatically</strong> from the links in your document. This enables:
  </p>
  <ul>
    <li>Cycle detection across the skill graph</li>
    <li>Visualization with <code>mdz graph --mermaid</code></li>
    <li>Understanding which skills depend on which</li>
  </ul>

  <h3>4. Validation</h3>
  <p>
    Multiple validation passes check for:
  </p>
  <ul>
    <li><strong>Type validation</strong> — Are referenced types defined?</li>
    <li><strong>Scope validation</strong> — Are variables defined before use?</li>
    <li><strong>Link validation</strong> — Do linked files exist?</li>
    <li><strong>Anchor validation</strong> — Do section anchors exist?</li>
    <li><strong>Contract validation</strong> — Do types match across boundaries?</li>
  </ul>

  <h3>5. Source = Output</h3>
  <p>
    <strong>Important:</strong> The compiler does not transform your source. The LLM sees 
    exactly what you wrote. Validation happens at build time; the validated source goes 
    directly to the LLM at runtime.
  </p>

  <h2>Skills</h2>
  
  <p>
    A skill is an MDZ document that defines agent behavior. Skills are:
  </p>
  
  <ul>
    <li>Self-contained units of behavior</li>
    <li>Composable through links</li>
    <li>Documented through frontmatter</li>
    <li>Validated by tooling before runtime</li>
  </ul>

  <h2>CAPS Keywords</h2>
  
  <p>
    Control flow and composition use uppercase keywords for visibility:
  </p>
  
  <pre><code class="mdz"><span class="zen-keyword">FOR EACH</span>, <span class="zen-keyword">PARALLEL</span>, <span class="zen-keyword">WHILE</span>, <span class="zen-keyword">DO</span>, <span class="zen-keyword">IF</span>, <span class="zen-keyword">THEN</span>, <span class="zen-keyword">ELSE</span>, <span class="zen-keyword">AND</span>, <span class="zen-keyword">OR</span>, <span class="zen-keyword">NOT</span>, <span class="zen-keyword">IN</span>, <span class="zen-keyword">BREAK</span>, <span class="zen-keyword">CONTINUE</span>
<span class="zen-keyword">USE</span>, <span class="zen-keyword">EXECUTE</span>, <span class="zen-keyword">DELEGATE</span>, <span class="zen-keyword">TO</span>, <span class="zen-keyword">WITH</span>, <span class="zen-keyword">GOTO</span></code></pre>
  
  <p>
    This makes structure scannable and avoids conflicts with prose. The LLM interprets 
    and executes these at runtime.
  </p>

  <h2>Links</h2>
  
  <p>
    MDZ uses link-based references to connect skills, agents, tools, and sections:
  </p>
  
  <ul>
    <li><code>~/skill/name</code> — Link to a skill</li>
    <li><code>~/agent/name</code> — Link to an agent</li>
    <li><code>~/tool/name</code> — Link to a tool</li>
    <li><code>#section</code> — Anchor to a local section</li>
    <li><code>~/skill/name#section</code> — Link with anchor</li>
  </ul>
  
  <p>
    The type is inferred from the folder path (<code>agent/</code>, <code>skill/</code>, <code>tool/</code>).
    Tooling validates that linked targets exist. You won't ship a skill that 
    references <code>~/skill/nonexistent</code>.
  </p>

  <h2>Types as Contracts</h2>
  
  <p>
    Types in MDZ are contracts for tooling, not runtime enforcement:
  </p>
  
  <ul>
    <li>Types describe what values represent</li>
    <li>Tooling checks that types match across module boundaries</li>
    <li>The LLM uses types as semantic hints</li>
    <li>There's no runtime type checking—just build-time validation</li>
  </ul>
  
  <h3>Built-in Primitives</h3>
  <p>
    MDZ includes built-in primitive types that don't need explicit definition:
  </p>
  <ul>
    <li><code>$String</code> — text content</li>
    <li><code>$Number</code> — numeric value</li>
    <li><code>$Boolean</code> — true or false</li>
  </ul>

  <h2>Prose First</h2>
  
  <p>
    MDZ skills read like natural language:
  </p>
  
  <ul>
    <li>No cryptic syntax</li>
    <li>Readable by non-programmers</li>
    <li>Self-documenting</li>
    <li>Valid markdown</li>
  </ul>
  
  <p>
    MDZ extends markdown—it doesn't replace it. An MDZ file is valid markdown, 
    viewable in any markdown renderer.
  </p>
</DocsLayout>
