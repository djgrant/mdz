---
import DocsLayout from '../../layouts/DocsLayout.astro';
---

<DocsLayout title="Syntax Reference">
  <h1>Syntax Reference</h1>
  
  <p class="lead">
    Complete reference for MDZ syntax, from document structure to control flow.
  </p>

  <h2>Document Structure</h2>
  
  <p>An MDZ document is a valid markdown file with these extensions:</p>
  
  <pre><code class="mdz"><span class="zen-comment">---
frontmatter (YAML)
---</span>

<span class="zen-heading"># Heading</span>

Body content with MDZ constructs</code></pre>

  <h3>Frontmatter</h3>
  
  <p>Required and optional fields in YAML frontmatter:</p>
  
  <pre><code class="mdz"><span class="zen-comment">---
name: skill-name              # Required: identifier (kebab-case)
description: When...          # Required: trigger description
---</span></code></pre>

  <p>
    <strong>Note:</strong> Dependencies can be declared in <code>uses:</code> or inferred from links in your document.
  </p>

  <h2>Types</h2>
  
  <h3>Type Definitions</h3>
  
  <p>Types provide semantic hints about values:</p>
  
  <pre><code class="mdz"><span class="zen-type">$TypeName</span>: <span class="zen-semantic">/natural language description/</span>

<span class="zen-type">$Task</span>: <span class="zen-semantic">/any task that an agent can execute/</span>
<span class="zen-type">$Strategy</span>: <span class="zen-string">"accumulate"</span> | <span class="zen-string">"independent"</span>
<span class="zen-type">$Result</span>: <span class="zen-string">"success"</span> | <span class="zen-string">"failure"</span> | <span class="zen-string">"pending"</span></code></pre>

  <h3>Type Forms</h3>
  
  <ul>
    <li><strong>Semantic type</strong>: <code>$Task: /any executable instruction/</code></li>
    <li><strong>Enum type</strong>: <code>$Strategy: "fast" | "thorough"</code> (variants separated by <strong>union</strong> operator <code>|</code>)</li>
    <li><strong>Tuple type</strong>: <code>($Task, $Strategy)</code></li>
    <li><strong>Array type</strong>: <code>$Task[]</code> (uses <strong>array suffix</strong>)</li>
    <li><strong>Function type</strong>: <code>$fn = $x =&gt; expression</code> (uses <strong>arrow</strong> operator)</li>
  </ul>

  <h2>Variables</h2>
  
  <p>Variables use the <strong>dollar sigil</strong> (<code>$</code>) prefix. The <strong>type annotation</strong> (<code>:</code>) is optional:</p>
  
  <h3>Variable Declaration</h3>
  
  <pre><code class="mdz"><span class="zen-variable">$name</span>: <span class="zen-type">$Type</span> = value   <span class="zen-comment">&lt;!-- typed declaration --&gt;</span>
<span class="zen-variable">$name</span> = value              <span class="zen-comment">&lt;!-- simple declaration --&gt;</span></code></pre>

  <h3>Examples</h3>
  
  <pre><code><span class="zen-variable">$current</span>: <span class="zen-type">$FilePath</span> = <span class="zen-variable">$SolutionPath</span>(0)
<span class="zen-variable">$iterations</span> = 0
<span class="zen-variable">$result</span>: <span class="zen-type">$ValidationResult</span></code></pre>

  <h3>Lambda Expressions</h3>
  
  <p>Functions use the <strong>arrow</strong> operator (<code>=&gt;</code>):</p>
  
  <pre><code class="mdz"><span class="zen-variable">$functionName</span> = <span class="zen-variable">$param</span> =&gt; expression
<span class="zen-variable">$functionName</span> = (<span class="zen-variable">$a</span>, <span class="zen-variable">$b</span>) =&gt; expression   <span class="zen-comment">&lt;!-- multiple params --&gt;</span>

<span class="zen-variable">$solutionPath</span> = <span class="zen-variable">$n</span> =&gt; `output-<span class="zen-variable">$n</span>.md`</code></pre>

  <h3>Semantic Type Annotations</h3>
  
  <p>When a variable needs a semantic description rather than a named type, use the <strong>semantic type</strong> syntax:</p>
  
  <pre><code class="mdz"><span class="zen-heading">## Input</span>
<span class="zen-variable">$skillPath</span>: <span class="zen-type">$String</span>  <span class="zen-comment">&lt;!-- path to the skill --&gt;</span>

<span class="zen-heading">## Context</span>
<span class="zen-variable">$skill</span>: <span class="zen-semantic">/the loaded and parsed skill AST from $skillPath/</span>

<span class="zen-heading">## Workflow</span>
1. Load skill source from <span class="zen-variable">$skillPath</span>
2. Parse into <span class="zen-variable">$skill</span> AST
3. <span class="zen-keyword">FOR</span> <span class="zen-variable">$statement</span> <span class="zen-keyword">IN</span> <span class="zen-variable">$skill</span>.statements
   Process <span class="zen-variable">$statement</span>
   <span class="zen-keyword">END</span></code></pre>

  <p>This pattern makes semantic transformations explicit and avoids confusion about where properties come from.</p>

  <h2>Links</h2>
  
  <p>Links reference other files using path syntax. The type is inferred from the folder:</p>
  
  <h3>Link Syntax</h3>
  
  <ul>
    <li><code>~/skill/name</code> — Link to a skill in the <code>skill/</code> folder</li>
    <li><code>~/agent/name</code> — Link to an agent in the <code>agent/</code> folder</li>
    <li><code>~/tool/name</code> — Link to a tool in the <code>tool/</code> folder</li>
    <li><code>#section</code> — Anchor to a section in the current file</li>
    <li><code>~/skill/name#section</code> — Link with anchor to a specific section</li>
  </ul>

  <h3>Folder Conventions</h3>
  
  <p>The folder in the path determines the reference type:</p>
  
  <ul>
    <li><code>agent/</code> — Agents for delegation</li>
    <li><code>skill/</code> — Reusable skill modules</li>
    <li><code>tool/</code> — Tool integrations</li>
  </ul>
  
  <h3>Examples</h3>
  
  <pre><code class="mdz"><span class="zen-reference">~/skill/code-review</span>           <span class="zen-comment">&lt;!-- skill reference --&gt;</span>
<span class="zen-reference">~/agent/architect</span>             <span class="zen-comment">&lt;!-- agent reference --&gt;</span>
<span class="zen-reference">~/tool/browser</span>                <span class="zen-comment">&lt;!-- tool reference --&gt;</span>
<span class="zen-reference">#validation-prompt</span>            <span class="zen-comment">&lt;!-- local anchor --&gt;</span>
<span class="zen-reference">~/skill/review#checklist</span>      <span class="zen-comment">&lt;!-- link with anchor --&gt;</span></code></pre>

  <h3>Section Anchors</h3>
  
  <p>Section names are derived from headings by:</p>
  
  <ol>
    <li>Converting to lowercase</li>
    <li>Replacing spaces with hyphens</li>
    <li>Removing special characters</li>
  </ol>
  
  <pre><code class="mdz"><span class="zen-heading">## Validate Prompt</span>
→ <span class="zen-reference">#validate-prompt</span>

<span class="zen-heading">## 2. Execute Phase</span>
→ <span class="zen-reference">#2-execute-phase</span></code></pre>

  <h2>Semantic Markers</h2>
  
  <p>The <code>/content/</code> syntax marks content for LLM interpretation. There are three forms:</p>
  
  <h3>Inline Semantic Markers</h3>
  
  <p>Mark inline content that the LLM should interpret contextually:</p>
  
  <pre><code class="mdz"><span class="zen-semantic">/appropriate location for this output/</span>
<span class="zen-semantic">/determine best strategy for <span class="zen-variable">$task</span>/</span></code></pre>

  <p>Variables are expanded before interpretation:</p>
  
  <pre><code class="mdz"><span class="zen-semantic">/the path for candidate <span class="zen-variable">$n</span>/</span>
<span class="zen-comment">&lt;!-- First $n is resolved, then LLM interprets --&gt;</span></code></pre>

  <h3>Inferred Variables</h3>
  
  <p>Use <code>$/name/</code> for variables the LLM infers and tracks without explicit declaration:</p>
  
  <pre><code class="mdz"><span class="zen-semantic">$/current-hypothesis/</span>
<span class="zen-semantic">$/best-candidate/</span></code></pre>

  <p>The LLM maintains these values implicitly based on context.</p>

  <h3>Semantic Type Annotations</h3>
  
  <p>Use <code>/description/</code> as a type annotation for variables that need semantic descriptions:</p>
  
  <pre><code><span class="zen-variable">$skill</span>: <span class="zen-semantic">/the loaded and parsed skill AST/</span>
<span class="zen-variable">$result</span>: <span class="zen-semantic">/outcome of the validation step/</span></code></pre>

  <h2>Control Flow</h2>
  
  <h3>For Loop</h3>
  
  <p>Iterate over a collection using the <strong>collection operator</strong> (<code>IN</code>):</p>
  
  <pre><code class="mdz"><span class="zen-keyword">FOR</span> <span class="zen-variable">$item</span> <span class="zen-keyword">IN</span> <span class="zen-variable">$collection</span>
  Process <span class="zen-variable">$item</span>
  Next step
<span class="zen-keyword">END</span></code></pre>

  <p>With <strong>destructuring</strong>:</p>

  <pre><code class="mdz"><span class="zen-keyword">FOR</span> (<span class="zen-variable">$task</span>, <span class="zen-variable">$strategy</span>) <span class="zen-keyword">IN</span> <span class="zen-variable">$transforms</span>
  Execute <span class="zen-variable">$task</span> with <span class="zen-variable">$strategy</span>
<span class="zen-keyword">END</span></code></pre>

  <h3>While Loop</h3>
  
  <p>Loop with a <strong>condition</strong>. The <code>DO</code> keyword delimits the condition:</p>
  
  <pre><code class="mdz"><span class="zen-keyword">WHILE</span> <span class="zen-semantic">/condition/</span> <span class="zen-keyword">AND</span> <span class="zen-variable">$iterations</span> &lt; 5 <span class="zen-keyword">DO</span>
  Perform iteration
  Update state
<span class="zen-keyword">END</span></code></pre>

  <h3>Conditional</h3>
  
  <p>Branch with <code>IF</code>/<code>THEN</code> and optional <strong>else clause</strong>:</p>
  
  <pre><code class="mdz"><span class="zen-keyword">IF</span> <span class="zen-variable">$condition</span> <span class="zen-keyword">THEN</span>
  Do this
<span class="zen-keyword">ELSE</span>
  Do that
<span class="zen-keyword">END</span>

<span class="zen-keyword">IF</span> <span class="zen-variable">$strategy</span> = <span class="zen-string">"accumulate"</span> <span class="zen-keyword">THEN</span>
  Validate incrementally
<span class="zen-keyword">ELSE</span>
  Collect all candidates
<span class="zen-keyword">END</span></code></pre>

  <h3>GOTO</h3>
  
  <p>Jump to a section anchor:</p>
  
  <pre><code class="mdz"><span class="zen-keyword">GOTO</span> <span class="zen-reference">#validation-prompt</span>
<span class="zen-keyword">GOTO</span> <span class="zen-reference">~/skill/helper#setup</span></code></pre>

  <h2>Composition</h2>
  
  <h3>USE (Skill Invocation)</h3>
  
  <p>Invoke a skill to perform a task:</p>
  
  <pre><code class="mdz"><span class="zen-keyword">USE</span> <span class="zen-reference">~/skill/code-review</span> <span class="zen-keyword">TO</span> <span class="zen-semantic">/check style/</span>

<span class="zen-keyword">USE</span> <span class="zen-reference">~/skill/orchestrate</span> <span class="zen-keyword">TO</span> <span class="zen-semantic">/coordinate tasks/</span></code></pre>

  <h3>WITH Clause (Passing Templates)</h3>
  
  <p>Pass a section template when invoking:</p>
  
  <pre><code class="mdz"><span class="zen-keyword">USE</span> <span class="zen-reference">~/skill/mapper</span> <span class="zen-keyword">TO</span> <span class="zen-semantic">/process items/</span> <span class="zen-keyword">WITH</span> <span class="zen-reference">#item-prompt</span></code></pre>

  <h3>EXECUTE (Tool Invocation)</h3>
  
  <p>Execute a tool to perform an action:</p>
  
  <pre><code class="mdz"><span class="zen-keyword">EXECUTE</span> <span class="zen-reference">~/tool/browser</span> <span class="zen-keyword">TO</span> <span class="zen-semantic">/take screenshot/</span>

<span class="zen-keyword">EXECUTE</span> <span class="zen-reference">~/tool/file-system</span> <span class="zen-keyword">TO</span> <span class="zen-semantic">/read config/</span></code></pre>

  <h3>DELEGATE (Agent Delegation)</h3>
  
  <p>Delegate to an agent for autonomous work:</p>
  
  <pre><code class="mdz"><span class="zen-keyword">DELEGATE</span> <span class="zen-semantic">/task description/</span> <span class="zen-keyword">TO</span> <span class="zen-reference">~/agent/architect</span>

<span class="zen-keyword">DELEGATE</span> <span class="zen-semantic">/research phase/</span> <span class="zen-keyword">TO</span> <span class="zen-reference">~/agent/explorer</span></code></pre>

  <h3>Pattern Summary</h3>
  
  <ul>
    <li><strong>USE</strong> — Invoke skills for reusable workflows</li>
    <li><strong>EXECUTE</strong> — Run tools for external actions</li>
    <li><strong>DELEGATE</strong> — Spawn autonomous agents</li>
    <li><strong>GOTO</strong> — Jump to section anchors</li>
    <li><strong>WITH</strong> — Pass template sections</li>
  </ul>

  <h2>Conventional Sections</h2>
  
  <p>While not required, these sections are conventional:</p>
  
  <pre><code class="mdz"><span class="zen-heading">## Types</span>
Type definitions

<span class="zen-heading">## Input</span>
Input parameter declarations

<span class="zen-heading">## Context</span>
Contextual variable declarations

<span class="zen-heading">## Workflow</span>
Main execution steps

<span class="zen-heading">## [Section Name]</span>
Reusable prompts/sub-sections</code></pre>
</DocsLayout>
