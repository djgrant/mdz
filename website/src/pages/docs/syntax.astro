---
import DocsLayout from '../../layouts/DocsLayout.astro';
---

<DocsLayout title="Syntax Reference">
  <h1>Syntax Reference</h1>
  
  <p class="lead">
    Complete reference for MDZ syntax, from document structure to control flow.
  </p>

  <h2>Document Structure</h2>
  
  <p>An MDZ document is a valid markdown file with these extensions:</p>
  
  <pre><code class="mdz"><span class="zen-comment">---
frontmatter (YAML)
---</span>

<span class="zen-heading"># Heading</span>

Body content with MDZ constructs</code></pre>

  <h3>Frontmatter</h3>
  
  <p>Required and optional fields in YAML frontmatter:</p>
  
  <pre><code class="mdz"><span class="zen-comment">---
name: skill-name              # Required: identifier (kebab-case)
description: When...          # Required: trigger description
uses:                         # Optional: skill dependencies
  - skill-a
  - skill-b
---</span></code></pre>

  <h2>Types</h2>
  
  <h3>Type Definitions</h3>
  
  <p>Types provide semantic hints about values:</p>
  
  <pre><code class="mdz"><span class="zen-type">$TypeName</span>: <span class="zen-semantic">/natural language description/</span>

<span class="zen-type">$Task</span>: <span class="zen-semantic">/any task that an agent can execute/</span>
<span class="zen-type">$Strategy</span>: <span class="zen-string">"accumulate"</span> | <span class="zen-string">"independent"</span>
<span class="zen-type">$Result</span>: <span class="zen-string">"success"</span> | <span class="zen-string">"failure"</span> | <span class="zen-string">"pending"</span></code></pre>

  <h3>Type Forms</h3>
  
  <ul>
    <li><strong>Semantic type</strong>: <code>$Task: /any executable instruction/</code></li>
    <li><strong>Enum type</strong>: <code>$Strategy: "fast" | "thorough"</code> (variants separated by <strong>union</strong> operator <code>|</code>)</li>
    <li><strong>Tuple type</strong>: <code>($Task, $Strategy)</code></li>
    <li><strong>Array type</strong>: <code>$Task[]</code> (uses <strong>array suffix</strong>)</li>
    <li><strong>Function type</strong>: <code>$fn = $x =&gt; expression</code> (uses <strong>arrow</strong> operator)</li>
  </ul>

  <h2>Variables</h2>
  
  <p>Variables use the <strong>dollar sigil</strong> (<code>$</code>) prefix. The <strong>type annotation</strong> (<code>:</code>) is optional:</p>
  
  <h3>Variable Declaration</h3>
  
  <pre><code class="mdz"><span class="zen-variable">$name</span>: <span class="zen-type">$Type</span> = value   <span class="zen-comment">&lt;!-- typed declaration --&gt;</span>
<span class="zen-variable">$name</span> = value              <span class="zen-comment">&lt;!-- simple declaration --&gt;</span></code></pre>

  <h3>Examples</h3>
  
  <pre><code>- <span class="zen-variable">$current</span>: <span class="zen-type">$FilePath</span> = <span class="zen-variable">$SolutionPath</span>(0)
- <span class="zen-variable">$iterations</span> = 0
- <span class="zen-variable">$result</span>: <span class="zen-type">$ValidationResult</span></code></pre>

  <h3>Lambda Expressions</h3>
  
  <p>Functions use the <strong>arrow</strong> operator (<code>=&gt;</code>):</p>
  
  <pre><code class="mdz"><span class="zen-variable">$functionName</span> = <span class="zen-variable">$param</span> =&gt; expression
<span class="zen-variable">$functionName</span> = (<span class="zen-variable">$a</span>, <span class="zen-variable">$b</span>) =&gt; expression   <span class="zen-comment">&lt;!-- multiple params --&gt;</span>

<span class="zen-variable">$solutionPath</span> = <span class="zen-variable">$n</span> =&gt; `output-<span class="zen-variable">$n</span>.md`</code></pre>

  <h3>Semantic Type Annotations</h3>
  
  <p>When a variable needs a semantic description rather than a named type, use the <strong>semantic type</strong> syntax:</p>
  
  <pre><code class="mdz"><span class="zen-heading">## Input</span>
- <span class="zen-variable">$skillPath</span>: <span class="zen-type">$String</span>  <span class="zen-comment">&lt;!-- path to the skill --&gt;</span>

<span class="zen-heading">## Context</span>
- <span class="zen-variable">$skill</span>: <span class="zen-semantic">/the loaded and parsed skill AST from $skillPath/</span>

<span class="zen-heading">## Workflow</span>
1. Load skill source from <span class="zen-variable">$skillPath</span>
2. Parse into <span class="zen-variable">$skill</span> AST
3. <span class="zen-keyword">FOR EACH</span> <span class="zen-variable">$statement</span> <span class="zen-keyword">IN</span> <span class="zen-variable">$skill</span>.statements:</code></pre>

  <p>This pattern makes semantic transformations explicit and avoids confusion about where properties come from.</p>

  <h2>References</h2>
  
  <h3>Skill Links</h3>
  
  <p>Reference another skill using wiki-link syntax:</p>
  
  <pre><code class="mdz"><span class="zen-reference">[[skill-name]]</span></code></pre>

  <h3>Section Links</h3>
  
  <p>Reference a section within a skill:</p>
  
  <pre><code class="mdz"><span class="zen-reference">[[skill-name#section-name]]</span>   <span class="zen-comment">&lt;!-- Section in another skill --&gt;</span>
[[#section-name]]             <span class="zen-comment">&lt;!-- Section in current skill --&gt;</span></code></pre>

  <h2>Semantic Markers</h2>
  
  <p>The <code>/content/</code> syntax marks content for LLM interpretation. There are three forms:</p>
  
  <h3>Inline Semantic Markers</h3>
  
  <p>Mark inline content that the LLM should interpret contextually:</p>
  
  <pre><code class="mdz"><span class="zen-semantic">/appropriate location for this output/</span>
<span class="zen-semantic">/determine best strategy for <span class="zen-variable">$task</span>/</span></code></pre>

  <p>Variables are expanded before interpretation:</p>
  
  <pre><code class="mdz"><span class="zen-semantic">/the path for candidate <span class="zen-variable">$n</span>/</span>
<span class="zen-comment">&lt;!-- First $n is resolved, then LLM interprets --&gt;</span></code></pre>

  <h3>Inferred Variables</h3>
  
  <p>Use <code>$/name/</code> for variables the LLM infers and tracks without explicit declaration:</p>
  
  <pre><code class="mdz"><span class="zen-semantic">$/current-hypothesis/</span>
<span class="zen-semantic">$/best-candidate/</span></code></pre>

  <p>The LLM maintains these values implicitly based on context.</p>

  <h3>Semantic Type Annotations</h3>
  
  <p>Use <code>/description/</code> as a type annotation for variables that need semantic descriptions:</p>
  
  <pre><code>- <span class="zen-variable">$skill</span>: <span class="zen-semantic">/the loaded and parsed skill AST/</span>
- <span class="zen-variable">$result</span>: <span class="zen-semantic">/outcome of the validation step/</span></code></pre>

  <h2>Control Flow</h2>
  
  <h3>For-Each Loop</h3>
  
  <p>Iterate over a collection using the <strong>collection operator</strong> (<code>IN</code>):</p>
  
  <pre><code class="mdz"><span class="zen-keyword">FOR EACH</span> <span class="zen-variable">$item</span> <span class="zen-keyword">IN</span> <span class="zen-variable">$collection</span>:
  - Process <span class="zen-variable">$item</span>
  - Next step</code></pre>

  <p>With <strong>destructuring</strong>:</p>

  <pre><code class="mdz"><span class="zen-keyword">FOR EACH</span> (<span class="zen-variable">$task</span>, <span class="zen-variable">$strategy</span>) <span class="zen-keyword">IN</span> <span class="zen-variable">$transforms</span>:
  - Execute <span class="zen-variable">$task</span> with <span class="zen-variable">$strategy</span></code></pre>

  <h3>While Loop</h3>
  
  <p>Loop with a <strong>condition</strong>. The <code>DO</code> keyword delimits the condition:</p>
  
  <pre><code class="mdz"><span class="zen-keyword">WHILE</span> condition <span class="zen-keyword">AND</span> <span class="zen-variable">$iterations</span> &lt; 5 <span class="zen-keyword">DO</span>:
  - Perform iteration
  - Update state</code></pre>

  <h3>Conditional</h3>
  
  <p>Branch with <code>IF</code>/<code>THEN</code> and optional <strong>else clause</strong>:</p>
  
  <pre><code class="mdz"><span class="zen-keyword">IF</span> <span class="zen-variable">$condition</span> <span class="zen-keyword">THEN</span>:
  - Do this
<span class="zen-keyword">ELSE</span>:
  - Do that

<span class="zen-keyword">IF</span> <span class="zen-variable">$strategy</span> = <span class="zen-string">"accumulate"</span> <span class="zen-keyword">THEN</span>:
  - Validate incrementally
<span class="zen-keyword">ELSE</span>:
  - Collect all candidates</code></pre>

  <h2>Composition</h2>
  
  <h3>Delegation</h3>
  
  <p>Invoke another skill using a <strong>skill link</strong> and <strong>with clause</strong>:</p>
  
  <pre><code>Execute <span class="zen-reference">[[orchestrate-map-reduce]]</span> <span class="zen-keyword">WITH</span>:
  - <span class="zen-variable">$transforms</span> = [(<span class="zen-string">"Apply heuristic"</span>, <span class="zen-string">"accumulate"</span>)]
  - <span class="zen-variable">$validator</span> = <span class="zen-reference">[[#validate-essence]]</span>
  - <span class="zen-variable">$return</span> = <span class="zen-string">"Report findings"</span></code></pre>

  <h3>Parameter Passing</h3>
  
  <p>Pass parameters via the <strong>with clause</strong>:</p>
  
  <pre><code>Delegate to <span class="zen-reference">[[skill-name]]</span> <span class="zen-keyword">WITH</span>:
  - <span class="zen-variable">$param1</span> = value1
  - <span class="zen-variable">$param2</span> = value2</code></pre>

  <h2>Conventional Sections</h2>
  
  <p>While not required, these sections are conventional:</p>
  
  <pre><code class="mdz"><span class="zen-heading">## Types</span>
Type definitions

<span class="zen-heading">## Input</span>
Input parameter declarations

<span class="zen-heading">## Context</span>
Contextual variable declarations

<span class="zen-heading">## Workflow</span>
Main execution steps

<span class="zen-heading">## [Section Name]</span>
Reusable prompts/sub-sections</code></pre>
</DocsLayout>
