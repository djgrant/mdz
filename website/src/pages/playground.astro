---
import Layout from "../layouts/Layout.astro";
import Header from "../components/Header.astro";
import examplesData from "../data/examples.json";

// Pass examples data to client
const projectsJson = JSON.stringify(examplesData.projects);
---

<Layout title="Playground - zen">
  <Header currentPath="/playground" fullWidth={true} />

  <!-- Mobile notice - show on small screens -->
  <div
    class="lg:hidden fixed inset-0 z-50 bg-[var(--color-bg)]/95 dark:bg-[var(--color-bg-dark)]/95 flex items-center justify-center p-8"
    id="mobile-notice"
  >
    <div class="text-center max-w-sm">
      <svg
        class="w-16 h-16 mx-auto mb-4 text-[var(--color-muted)] dark:text-[var(--color-muted-dark)]"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="1.5"
          d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"
        ></path>
      </svg>
      <h2
        class="text-xl font-medium mb-2 text-[var(--color-text)] dark:text-[var(--color-text-dark)]"
      >
        Best on Desktop
      </h2>
      <p
        class="text-[var(--color-muted)] dark:text-[var(--color-muted-dark)] mb-6"
      >
        The playground works best on larger screens where you can see the editor
        and validation results side by side.
      </p>
      <button
        onclick="document.getElementById('mobile-notice').remove()"
        class="px-4 py-2 bg-[var(--color-accent)] text-white rounded-lg hover:opacity-90 transition-opacity"
      >
        Continue Anyway
      </button>
    </div>
  </div>

  <div class="h-[calc(100vh-4rem)] flex flex-col">
    <!-- Top Bar (mobile only) -->
    <div
      class="lg:hidden flex items-center justify-between gap-2 px-4 py-2 border-b border-[var(--color-border)] dark:border-[var(--color-border-dark)] bg-[var(--color-bg)] dark:bg-[var(--color-bg-dark)]"
    >
      <select
        id="scenario-mobile"
        class="text-sm bg-transparent border border-[var(--color-border)] dark:border-[var(--color-border-dark)] rounded px-2 py-1 text-[var(--color-text)] dark:text-[var(--color-text-dark)]"
      >
      </select>
      <span
        id="validation-status"
        class="text-xs text-[var(--color-muted)] dark:text-[var(--color-muted-dark)]"
      ></span>
    </div>

    <!-- Main Content with Sidebar -->
    <div class="flex-1 flex overflow-hidden">
      <!-- Sidebar - hidden on mobile -->
      <div
        id="sidebar"
        class="hidden lg:flex flex-col w-60 xl:w-72 border-r border-[var(--color-border)] dark:border-[var(--color-border-dark)] bg-[var(--color-bg)] dark:bg-[var(--color-bg-dark)]"
      >
        <!-- Examples Section -->
        <div class="p-2">
          <div class="text-xs font-medium text-[var(--color-muted)] dark:text-[var(--color-muted-dark)] uppercase tracking-wide px-2 py-1">Examples</div>
          <div id="project-list" class="flex flex-col"></div>
        </div>

        <!-- Files Section (when project selected) -->
        <div id="file-tree-container" class="hidden flex-1 overflow-auto border-t border-[var(--color-border)] dark:border-[var(--color-border-dark)]">
          <div class="text-xs font-medium text-[var(--color-muted)] dark:text-[var(--color-muted-dark)] uppercase tracking-wide px-3 py-2">Files</div>
          <div id="file-tree" class="px-2 pb-3"></div>
        </div>
      </div>

      <!-- Editor and Insights Area -->
      <div class="flex-1 flex flex-col lg:flex-row overflow-hidden">
        <!-- Left: Editor -->
        <div
          class="flex-1 lg:flex-[3] flex flex-col border-b lg:border-b-0 lg:border-r border-[var(--color-border)] dark:border-[var(--color-border-dark)] min-h-[300px] lg:min-h-0"
        >
        <div
          class="px-4 py-2 text-xs font-medium text-[var(--color-muted)] dark:text-[var(--color-muted-dark)] uppercase tracking-wide border-b border-[var(--color-border)] dark:border-[var(--color-border-dark)] flex items-center justify-between"
        >
          <span>Source</span>
          <span id="file-indicator" class="font-mono">skill.mdz</span>
        </div>
        <div id="editor" class="flex-1"></div>
      </div>

      <!-- Right: Insights Panel -->
      <div
        class="flex-1 lg:flex-[2] flex flex-col bg-[var(--color-bg-secondary)] dark:bg-[var(--color-bg-secondary-dark)] overflow-auto"
      >
        <!-- Diagnostics -->
        <div
          class="border-b border-[var(--color-border)] dark:border-[var(--color-border-dark)]"
        >
          <div
            class="px-4 py-2 text-xs font-medium text-[var(--color-muted)] dark:text-[var(--color-muted-dark)] uppercase tracking-wide flex items-center gap-2"
          >
            <span>Diagnostics</span>
            <span
              id="error-count"
              class="px-1.5 py-0.5 rounded-full text-xs bg-green-500/20 text-green-600 dark:text-green-400"
              >0 issues</span
            >
          </div>
          <div id="diagnostics" class="px-4 pb-4 max-h-48 overflow-auto">
            <div
              class="text-sm text-green-600 dark:text-green-400 flex items-center gap-2"
            >
              <svg
                class="w-4 h-4"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M5 13l4 4L19 7"></path>
              </svg>
              No issues found
            </div>
          </div>
        </div>

        <!-- Dependency Graph - hidden on mobile -->
        <div class="hidden md:flex flex-1 flex-col">
          <div
            class="px-4 py-2 text-xs font-medium text-[var(--color-muted)] dark:text-[var(--color-muted-dark)] uppercase tracking-wide border-b border-[var(--color-border)] dark:border-[var(--color-border-dark)]"
          >
            Dependency Graph
          </div>
          <div
            id="graph"
            class="flex-1 flex items-center justify-center p-4 min-h-[150px]"
          >
            <svg id="graph-svg" class="w-full h-full"></svg>
          </div>
        </div>

        <!-- Insight Message -->
        <div
          id="insight"
          class="px-4 py-3 bg-indigo-500/10 border-t border-[var(--color-border)] dark:border-[var(--color-border-dark)]"
        >
          <p class="text-sm text-indigo-600 dark:text-indigo-400">
            üí° <strong>Why this matters:</strong> zen validates your skill definitions
            before runtime‚Äîcatching broken references, type errors, and missing dependencies
            early.
          </p>
        </div>
      </div>
      </div>
    </div>

    <!-- Status Bar -->
    <div
      class="flex items-center justify-between px-4 py-1.5 text-xs border-t border-[var(--color-border)] dark:border-[var(--color-border-dark)] bg-[var(--color-bg)] dark:bg-[var(--color-bg-dark)] text-[var(--color-muted)] dark:text-[var(--color-muted-dark)]"
    >
      <div class="flex items-center gap-2 sm:gap-4">
        <span id="skills-count">Skills: 0</span>
        <span id="refs-count" class="hidden sm:inline">References: 0</span>
        <span id="types-count" class="hidden sm:inline">Types: 0</span>
      </div>
      <span id="position">Line 1, Col 1</span>
    </div>
  </div>
</Layout>

<style>
  :root {
    --color-bg-secondary: #f5f5f5;
    --color-bg-secondary-dark: #111;
  }

  .diagnostic-item {
    cursor: pointer;
    transition: background-color 0.15s;
  }
  .diagnostic-item:hover {
    background-color: rgba(99, 102, 241, 0.1);
  }

  /* Project/Example list - VS Code style */
  :global(.project-item) {
    display: flex;
    align-items: center;
    height: 22px;
    padding: 0 8px;
    cursor: pointer;
    user-select: none;
    white-space: nowrap;
    border-radius: 3px;
    font-family: 'JetBrains Mono', 'Fira Code', monospace;
    font-size: 12px;
    color: #171717;
  }

  :global(.project-item:hover) {
    background-color: rgba(0, 0, 0, 0.05);
  }

  @media (prefers-color-scheme: dark) {
    :global(.project-item) {
      color: #EDEDED;
    }
    :global(.project-item:hover) {
      background-color: rgba(255, 255, 255, 0.05);
    }
  }

  :global(.project-item.active) {
    background-color: var(--color-accent);
    color: white;
  }

  :global(.project-item.active:hover) {
    background-color: var(--color-accent);
  }

  :global(.project-icon) {
    width: 14px;
    height: 14px;
    flex-shrink: 0;
    margin-right: 6px;
    color: #e8a838;
  }

  :global(.project-item.active .project-icon) {
    color: white;
  }

  :global(.project-name) {
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Graph node clickable - ensure SVG elements get cursor */
  .graph-node {
    cursor: pointer !important;
  }
  .graph-node rect,
  .graph-node text {
    cursor: pointer !important;
  }
  .graph-node:hover {
    opacity: 0.8;
  }

  /* File tree styles (VS Code-style) */
  :global(.tree-list) {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  :global(.tree-item) {
    display: flex;
    align-items: center;
    height: 22px;
    padding-right: 8px;
    cursor: pointer;
    user-select: none;
    white-space: nowrap;
    border-radius: 3px;
  }

  :global(.tree-item:hover) {
    background-color: rgba(0, 0, 0, 0.05);
  }

  :global(.dark .tree-item:hover) {
    background-color: rgba(255, 255, 255, 0.05);
  }

  :global(.tree-item.active) {
    background-color: var(--color-accent);
    color: white;
  }

  :global(.tree-item.active:hover) {
    background-color: var(--color-accent);
  }

  :global(.tree-item.active .tree-icon) {
    color: white;
  }

  :global(.tree-item.active .tree-chevron) {
    color: white;
  }

  :global(.tree-chevron) {
    width: 12px;
    height: 12px;
    flex-shrink: 0;
    margin-right: 2px;
    color: var(--color-muted);
    transition: transform 0.15s ease;
  }

  :global(.dark .tree-chevron) {
    color: #A3A3A3;
  }

  :global(.tree-chevron.expanded) {
    transform: rotate(90deg);
  }

  :global(.tree-chevron-spacer) {
    width: 12px;
    height: 12px;
    flex-shrink: 0;
    margin-right: 2px;
  }

  :global(.tree-icon) {
    width: 14px;
    height: 14px;
    flex-shrink: 0;
    margin-right: 4px;
    color: var(--color-muted);
  }

  :global(.dark .tree-icon) {
    color: #A3A3A3;
  }

  :global(.tree-folder .tree-icon) {
    color: #e8a838;
  }

  :global(.dark .tree-folder .tree-icon) {
    color: #e8a838;
  }

  :global(.tree-name) {
    font-family: 'JetBrains Mono', 'Fira Code', monospace;
    font-size: 12px;
    line-height: 22px;
    color: #171717;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  @media (prefers-color-scheme: dark) {
    :global(.tree-name) {
      color: #EDEDED;
    }
  }

  :global(.tree-item.active .tree-name) {
    color: white;
  }
</style>

<script
  is:inline
  src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"
></script>

<!-- Inject examples data from build -->
<script is:inline define:vars={{ projectsJson }}>
  window.__PLAYGROUND_PROJECTS__ = JSON.parse(projectsJson);
</script>

<script type="module">
  // Load projects from build-time data
  const projects = window.__PLAYGROUND_PROJECTS__;

  let editor = null;
  let worker = null;
  let requestId = 0;
  let pendingRequests = new Map();
  let validateTimeout = null;
  
  // Project state
  let currentProject = null;
  let currentProjectFiles = {};
  let currentFile = null;
  let projectValidationResult = null;

  // Initialize worker
  function initWorker() {
    worker = new Worker("/zen-worker.js");

    worker.addEventListener("message", (event) => {
      const { type, id, result, error } = event.data;

      if (type === "ready") {
        console.log("zen worker ready");
        return;
      }

      if (type === "error") {
        console.error("Worker error:", error);
        const resolve = pendingRequests.get(id);
        if (resolve) {
          resolve({ error });
          pendingRequests.delete(id);
        }
        return;
      }

      const resolve = pendingRequests.get(id);
      if (resolve) {
        resolve(result);
        pendingRequests.delete(id);
      }
    });

    worker.addEventListener("error", (error) => {
      console.error("Worker error:", error);
    });
  }

  function sendToWorker(type, data) {
    return new Promise((resolve) => {
      const id = ++requestId;
      pendingRequests.set(id, resolve);
      worker.postMessage({ type, id, ...data });
    });
  }

  async function validate(source) {
    document.getElementById("validation-status").textContent = "Validating...";

    try {
      const result = await sendToWorker("validate", { source });

      if (result.error) {
        console.error("Validation error:", result.error);
        document.getElementById("validation-status").textContent = "Error";
        return;
      }

      document.getElementById("validation-status").textContent = "";
      renderValidationResult(result);
    } catch (error) {
      console.error("Validation failed:", error);
      document.getElementById("validation-status").textContent = "Error";
    }
  }

  async function validateProject(files) {
    document.getElementById("validation-status").textContent = "Validating project...";

    try {
      const result = await sendToWorker("validateProject", { files });

      if (result.error) {
        console.error("Project validation error:", result.error);
        document.getElementById("validation-status").textContent = "Error";
        return;
      }

      document.getElementById("validation-status").textContent = "";
      projectValidationResult = result;
      
      // Render the current file's diagnostics
      if (currentFile && result.fileResults[currentFile]) {
        renderDiagnostics(result.fileResults[currentFile].diagnostics);
        updateCounts(result.fileResults[currentFile].metadata, result.fileResults[currentFile].dependencies);
      }
      
      // Render unified graph
      renderProjectGraph(result.unifiedGraph);
      updateProjectInsight(result);
    } catch (error) {
      console.error("Project validation failed:", error);
      document.getElementById("validation-status").textContent = "Error";
    }
  }

  function renderValidationResult(result) {
    renderDiagnostics(result.diagnostics);
    renderGraph(result.metadata, result.dependencies);
    updateCounts(result.metadata, result.dependencies);
    updateInsight(result.diagnostics);
  }

  function renderDiagnostics(diagnostics) {
    const container = document.getElementById("diagnostics");
    const countEl = document.getElementById("error-count");

    if (diagnostics.length === 0) {
      container.innerHTML = `
        <div class="text-sm text-green-600 dark:text-green-400 flex items-center gap-2">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
          </svg>
          No issues found
        </div>
      `;
      countEl.textContent = "0 issues";
      countEl.className =
        "px-1.5 py-0.5 rounded-full text-xs bg-green-500/20 text-green-600 dark:text-green-400";

      // Clear Monaco markers when there are no diagnostics
      if (editor && monaco) {
        monaco.editor.setModelMarkers(editor.getModel(), "zen", []);
      }
      return;
    }

    const errors = diagnostics.filter((d) => d.severity === "error").length;
    const warnings = diagnostics.filter((d) => d.severity === "warning").length;

    let countText = "";
    if (errors > 0) countText += `${errors} error${errors !== 1 ? "s" : ""}`;
    if (warnings > 0) {
      if (countText) countText += ", ";
      countText += `${warnings} warning${warnings !== 1 ? "s" : ""}`;
    }

    countEl.textContent =
      countText ||
      `${diagnostics.length} issue${diagnostics.length !== 1 ? "s" : ""}`;
    countEl.className =
      errors > 0
        ? "px-1.5 py-0.5 rounded-full text-xs bg-red-500/20 text-red-600 dark:text-red-400"
        : "px-1.5 py-0.5 rounded-full text-xs bg-yellow-500/20 text-yellow-600 dark:text-yellow-400";

    container.innerHTML = diagnostics
      .map((d) => {
        const severityClass =
          d.severity === "error"
            ? "text-red-600 dark:text-red-400"
            : d.severity === "warning"
              ? "text-yellow-600 dark:text-yellow-400"
              : "text-blue-600 dark:text-blue-400";

        const icon =
          d.severity === "error"
            ? "üî¥"
            : d.severity === "warning"
              ? "‚ö†Ô∏è"
              : "‚ÑπÔ∏è";

        return `
        <div class="diagnostic-item mb-2 last:mb-0 p-1.5 -mx-1.5 rounded" onclick="jumpToLine(${d.line}, ${d.column})">
          <div class="text-sm ${severityClass} flex items-start gap-2">
            <span class="font-mono text-xs mt-0.5 shrink-0">L${d.line}</span>
            <span>${icon} [${d.code}] ${d.message}</span>
          </div>
        </div>
      `;
      })
      .join("");

    // Update Monaco markers
    if (editor && monaco) {
      const markers = diagnostics.map((d) => ({
        severity:
          d.severity === "error"
            ? monaco.MarkerSeverity.Error
            : d.severity === "warning"
              ? monaco.MarkerSeverity.Warning
              : monaco.MarkerSeverity.Info,
        startLineNumber: d.line,
        startColumn: d.column,
        endLineNumber: d.endLine || d.line,
        endColumn: d.endColumn || d.column + 10,
        message: `[${d.code}] ${d.message}`,
      }));
      monaco.editor.setModelMarkers(editor.getModel(), "zen", markers);
    }
  }

  function renderGraph(metadata, dependencies) {
    const svg = document.getElementById("graph-svg");
    const container = document.getElementById("graph");

    // Skip rendering if the graph container is hidden (mobile)
    if (!container || container.offsetParent === null) {
      return;
    }

    const width = container.clientWidth - 32;
    const height = container.clientHeight - 32;

    // Build nodes: current skill + all dependencies
    const nodes = [];
    const nodeMap = new Map();

    // Add the main skill node
    if (metadata.name) {
      nodes.push({ id: metadata.name, isMain: true });
      nodeMap.set(metadata.name, nodes.length - 1);
    }

    // Add dependency nodes
    for (const dep of dependencies.nodes) {
      if (!nodeMap.has(dep)) {
        nodes.push({ id: dep, isMain: false });
        nodeMap.set(dep, nodes.length - 1);
      }
    }

    if (nodes.length === 0) {
      svg.innerHTML = `<text x="50%" y="50%" text-anchor="middle" fill="currentColor" class="text-sm text-[var(--color-muted)] dark:text-[var(--color-muted-dark)]">No dependencies</text>`;
      return;
    }

    // Simple layout: main node at top, dependencies in a row below
    const mainNode = nodes.find((n) => n.isMain);
    const depNodes = nodes.filter((n) => !n.isMain);

    // Position nodes
    const centerX = width / 2;
    const topY = 40;
    const bottomY = height - 50;

    if (mainNode) {
      mainNode.x = centerX;
      mainNode.y = topY;
    }

    // Distribute dependency nodes evenly
    const depWidth = Math.min(width - 100, depNodes.length * 120);
    const startX = centerX - depWidth / 2 + 60;
    const spacing = depNodes.length > 1 ? depWidth / (depNodes.length - 1) : 0;

    depNodes.forEach((node, i) => {
      node.x = depNodes.length === 1 ? centerX : startX + i * spacing;
      node.y = bottomY;
    });

    // Build edges
    const edges = [];
    if (mainNode) {
      for (const edge of dependencies.edges) {
        const targetNode = nodes.find((n) => n.id === edge.target);
        if (targetNode) {
          edges.push({
            from: mainNode,
            to: targetNode,
            type: edge.type,
          });
        }
      }
    }

    // Render
    let html = `
      <defs>
        <marker id="arrowhead-purple" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#8B5CF6"/>
        </marker>
        <marker id="arrowhead-blue" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#3B82F6"/>
        </marker>
        <marker id="arrowhead-gray" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#6B7280"/>
        </marker>
      </defs>
    `;

    // Draw edges
    for (const edge of edges) {
      const color =
        edge.type === "uses"
          ? "#8B5CF6"
          : "#6B7280";
      const markerEnd =
        edge.type === "uses"
          ? "arrowhead-purple"
          : "arrowhead-gray";
      const dashArray = edge.type === "reference" ? "4" : "none";

      html += `<line
        x1="${edge.from.x}" y1="${edge.from.y + 15}"
        x2="${edge.to.x}" y2="${edge.to.y - 15}"
        stroke="${color}"
        stroke-width="2"
        stroke-dasharray="${dashArray}"
        marker-end="url(#${markerEnd})"/>`;
    }

    // Draw nodes
    for (const node of nodes) {
      const fillColor = node.isMain ? "#E0E7FF" : "#F3F4F6";
      const strokeColor = node.isMain ? "#6366F1" : "#9CA3AF";
      const textColor = node.isMain ? "#4338CA" : "#374151";
      const nodeWidth = Math.min(100, Math.max(60, node.id.length * 7 + 20));

      html += `
        <g class="cursor-pointer hover:opacity-80 transition-opacity">
          <rect x="${node.x - nodeWidth / 2}" y="${node.y - 15}" width="${nodeWidth}" height="30" rx="4" fill="${fillColor}" stroke="${strokeColor}" stroke-width="1.5"/>
          <text x="${node.x}" y="${node.y + 4}" text-anchor="middle" font-size="11" fill="${textColor}" font-family="monospace">${node.id.length > 14 ? node.id.slice(0, 12) + "..." : node.id}</text>
        </g>
      `;
    }

    svg.innerHTML = html;
  }

  function updateCounts(metadata, dependencies) {
    document.getElementById("skills-count").textContent =
      `Skills: ${dependencies.nodes.length + (metadata.name ? 1 : 0)}`;
    document.getElementById("refs-count").textContent =
      `References: ${metadata.references.length}`;
    document.getElementById("types-count").textContent =
      `Types: ${metadata.types.length}`;
  }

  function updateInsight(diagnostics) {
    const insightEl = document.getElementById("insight");

    if (diagnostics.length === 0) {
      insightEl.innerHTML = `<p class="text-sm text-indigo-600 dark:text-indigo-400">üí° <strong>All checks passed!</strong> Your skill definition is valid.</p>`;
    } else {
      const errors = diagnostics.filter((d) => d.severity === "error");
      const warnings = diagnostics.filter((d) => d.severity === "warning");

      let message = "";
      if (errors.length > 0) {
        message = `üî¥ <strong>${errors.length} error${errors.length !== 1 ? "s" : ""} found:</strong> Fix these issues before your agent can safely run this skill.`;
      } else if (warnings.length > 0) {
        message = `‚ö†Ô∏è <strong>${warnings.length} warning${warnings.length !== 1 ? "s" : ""}:</strong> These won't break your skill, but may indicate issues.`;
      }

      insightEl.innerHTML = `<p class="text-sm text-indigo-600 dark:text-indigo-400">${message}</p>`;
    }
  }

  function updateProjectInsight(result) {
    const insightEl = document.getElementById("insight");
    const project = projects[currentProject];
    
    // Count total diagnostics across all files
    let totalErrors = 0;
    let totalWarnings = 0;
    for (const fileResult of Object.values(result.fileResults)) {
      totalErrors += fileResult.diagnostics.filter(d => d.severity === "error").length;
      totalWarnings += fileResult.diagnostics.filter(d => d.severity === "warning").length;
    }
    
    if (totalErrors === 0 && totalWarnings === 0) {
      insightEl.innerHTML = `<p class="text-sm text-indigo-600 dark:text-indigo-400">üìÅ <strong>${project?.name || "Project"}:</strong> All ${Object.keys(result.fileResults).length} files validated successfully. Click nodes in the graph to explore dependencies.</p>`;
    } else {
      let message = `üìÅ <strong>${project?.name || "Project"}:</strong> `;
      if (totalErrors > 0) message += `${totalErrors} error${totalErrors !== 1 ? "s" : ""} `;
      if (totalWarnings > 0) message += `${totalWarnings} warning${totalWarnings !== 1 ? "s" : ""} `;
      message += `across ${Object.keys(result.fileResults).length} files.`;
      insightEl.innerHTML = `<p class="text-sm text-indigo-600 dark:text-indigo-400">${message}</p>`;
    }
  }

  function renderProjectGraph(unifiedGraph) {
    const svg = document.getElementById("graph-svg");
    const container = document.getElementById("graph");

    if (!container || container.offsetParent === null) {
      return;
    }

    const width = container.clientWidth - 32;
    const height = container.clientHeight - 32;

    if (unifiedGraph.nodes.length === 0) {
      svg.innerHTML = `<text x="50%" y="50%" text-anchor="middle" fill="currentColor" class="text-sm text-[var(--color-muted)] dark:text-[var(--color-muted-dark)]">No skills found</text>`;
      return;
    }

    // Find the current skill name from the current file
    const currentSkill = unifiedGraph.nodes.find(n => n.file === currentFile)?.id;
    
    // Filter graph to center around the selected module
    let filteredNodes = unifiedGraph.nodes;
    let filteredEdges = unifiedGraph.edges;
    
    if (currentSkill) {
      // Build adjacency maps for traversal
      const dependencies = new Map(); // skill -> skills it depends on
      const dependents = new Map();   // skill -> skills that depend on it
      
      for (const node of unifiedGraph.nodes) {
        dependencies.set(node.id, new Set());
        dependents.set(node.id, new Set());
      }
      
      for (const edge of unifiedGraph.edges) {
        if (dependencies.has(edge.source)) {
          dependencies.get(edge.source).add(edge.target);
        }
        if (dependents.has(edge.target)) {
          dependents.get(edge.target).add(edge.source);
        }
      }
      
      // Collect all connected nodes (transitive dependencies and dependents)
      const connectedNodes = new Set([currentSkill]);
      
      // Traverse dependencies (what this skill uses)
      const depsQueue = [currentSkill];
      while (depsQueue.length > 0) {
        const node = depsQueue.shift();
        for (const dep of dependencies.get(node) || []) {
          if (!connectedNodes.has(dep)) {
            connectedNodes.add(dep);
            depsQueue.push(dep);
          }
        }
      }
      
      // Traverse dependents (what uses this skill)
      const deptsQueue = [currentSkill];
      while (deptsQueue.length > 0) {
        const node = deptsQueue.shift();
        for (const dept of dependents.get(node) || []) {
          if (!connectedNodes.has(dept)) {
            connectedNodes.add(dept);
            deptsQueue.push(dept);
          }
        }
      }
      
      // Filter to only connected nodes and their edges
      filteredNodes = unifiedGraph.nodes.filter(n => connectedNodes.has(n.id));
      filteredEdges = unifiedGraph.edges.filter(e => 
        connectedNodes.has(e.source) && connectedNodes.has(e.target)
      );
    }

    if (filteredNodes.length === 0) {
      svg.innerHTML = `<text x="50%" y="50%" text-anchor="middle" fill="currentColor" class="text-sm text-[var(--color-muted)] dark:text-[var(--color-muted-dark)]">No dependencies</text>`;
      return;
    }

    // Position nodes in a hierarchical layout
    const nodes = filteredNodes.map((n, i) => ({
      ...n,
      x: 0,
      y: 0,
    }));

    // Build adjacency for topological sort
    const nodeIndex = new Map(nodes.map((n, i) => [n.id, i]));
    const inDegree = new Array(nodes.length).fill(0);
    const children = nodes.map(() => []);
    
    for (const edge of filteredEdges) {
      const sourceIdx = nodeIndex.get(edge.source);
      const targetIdx = nodeIndex.get(edge.target);
      if (sourceIdx !== undefined && targetIdx !== undefined) {
        children[sourceIdx].push(targetIdx);
        inDegree[targetIdx]++;
      }
    }

    // Assign levels (topological order)
    const levels = new Array(nodes.length).fill(0);
    const queue = [];
    for (let i = 0; i < nodes.length; i++) {
      if (inDegree[i] === 0) queue.push(i);
    }
    
    while (queue.length > 0) {
      const idx = queue.shift();
      for (const child of children[idx]) {
        levels[child] = Math.max(levels[child], levels[idx] + 1);
        inDegree[child]--;
        if (inDegree[child] === 0) queue.push(child);
      }
    }

    // Group nodes by level
    const maxLevel = Math.max(...levels);
    const levelGroups = [];
    for (let i = 0; i <= maxLevel; i++) {
      levelGroups.push([]);
    }
    nodes.forEach((n, i) => {
      levelGroups[levels[i]].push(i);
    });

    // Position nodes
    const levelHeight = height / (maxLevel + 2);
    levelGroups.forEach((group, level) => {
      const levelWidth = width / (group.length + 1);
      group.forEach((nodeIdx, i) => {
        nodes[nodeIdx].x = levelWidth * (i + 1);
        nodes[nodeIdx].y = levelHeight * (level + 1);
      });
    });

    // Render
    let html = `
      <defs>
        <marker id="arrowhead-purple" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#8B5CF6"/>
        </marker>
        <marker id="arrowhead-gray" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#6B7280"/>
        </marker>
      </defs>
    `;

    // Draw edges
    for (const edge of filteredEdges) {
      const sourceIdx = nodeIndex.get(edge.source);
      const targetIdx = nodeIndex.get(edge.target);
      if (sourceIdx === undefined || targetIdx === undefined) continue;
      
      const from = nodes[sourceIdx];
      const to = nodes[targetIdx];
      const color = edge.type === "uses" ? "#8B5CF6" : "#6B7280";
      const markerEnd = edge.type === "uses" ? "arrowhead-purple" : "arrowhead-gray";
      const dashArray = edge.type === "reference" ? "4" : "none";

      html += `<line
        x1="${from.x}" y1="${from.y + 15}"
        x2="${to.x}" y2="${to.y - 15}"
        stroke="${color}"
        stroke-width="2"
        stroke-dasharray="${dashArray}"
        marker-end="url(#${markerEnd})"/>`;
    }

    // Draw nodes
    for (const node of nodes) {
      const isCurrentFile = node.file === currentFile;
      const isInProject = node.file !== null;
      const fillColor = isCurrentFile ? "#E0E7FF" : (isInProject ? "#D1FAE5" : "#F3F4F6");
      const strokeColor = isCurrentFile ? "#6366F1" : (isInProject ? "#10B981" : "#9CA3AF");
      const textColor = isCurrentFile ? "#4338CA" : (isInProject ? "#047857" : "#374151");
      const nodeWidth = Math.min(110, Math.max(70, node.id.length * 7 + 20));
      const clickHandler = node.file ? `onclick="switchToFile('${node.file}')"` : "";

      html += `
        <g class="graph-node" ${clickHandler}>
          <rect x="${node.x - nodeWidth / 2}" y="${node.y - 15}" width="${nodeWidth}" height="30" rx="4" fill="${fillColor}" stroke="${strokeColor}" stroke-width="1.5"/>
          <text x="${node.x}" y="${node.y + 4}" text-anchor="middle" font-size="11" fill="${textColor}" font-family="monospace">${node.id.length > 14 ? node.id.slice(0, 12) + "..." : node.id}</text>
        </g>
      `;
    }

    svg.innerHTML = html;
  }

  function renderProjectList() {
    const listEl = document.getElementById("project-list");
    const mobileSelect = document.getElementById("scenario-mobile");
    const projectIds = Object.keys(projects);
    
    // Project icon (open folder style)
    const projectIcon = `<svg class="project-icon" width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M20 6h-8l-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V6h5.17l2 2H20v10z"/></svg>`;
    
    listEl.innerHTML = projectIds.map(projectId => {
      const project = projects[projectId];
      const isActive = projectId === currentProject;
      return `<button class="project-item ${isActive ? "active" : ""}" onclick="switchToProject('${projectId}')" title="${project.description}">${projectIcon}<span class="project-name">${project.name}</span></button>`;
    }).join("");
    
    // Update mobile select
    mobileSelect.innerHTML = projectIds.map(projectId => {
      const project = projects[projectId];
      return `<option value="project:${projectId}">${project.name}</option>`;
    }).join("");
    
    if (currentProject) {
      mobileSelect.value = `project:${currentProject}`;
    }
  }

  // Track expanded state for folders
  const expandedFolders = new Set();
  
  /**
   * Build a tree structure from flat file paths
   * Returns: { name, path, type: 'file' | 'folder', children: [] }
   */
  function buildFileTree(filePaths) {
    const root = { name: '', path: '', type: 'folder', children: [] };
    
    for (const filePath of filePaths) {
      const parts = filePath.split('/');
      let current = root;
      let pathSoFar = '';
      
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        pathSoFar = pathSoFar ? `${pathSoFar}/${part}` : part;
        const isFile = i === parts.length - 1;
        
        let child = current.children.find(c => c.name === part);
        
        if (!child) {
          child = {
            name: part,
            path: pathSoFar,
            type: isFile ? 'file' : 'folder',
            children: []
          };
          current.children.push(child);
        }
        
        current = child;
      }
    }
    
    // Sort children: folders first, then files, both alphabetically
    function sortTree(node) {
      node.children.sort((a, b) => {
        if (a.type !== b.type) {
          return a.type === 'folder' ? -1 : 1;
        }
        return a.name.localeCompare(b.name);
      });
      node.children.forEach(sortTree);
    }
    sortTree(root);
    
    return root;
  }
  
  /**
   * Render a single tree node (file or folder)
   */
  function renderTreeNode(node, depth = 0) {
    const isFolder = node.type === 'folder';
    const isExpanded = expandedFolders.has(node.path);
    const isActive = !isFolder && node.path === currentFile;
    const displayName = isFolder ? node.name : node.name.replace(/\.mdz$/, '');
    
    // Calculate indentation (14px per level)
    const indent = depth * 14;
    
    // SVG icons inline (chevron, folder, file)
    const chevronIcon = `<svg class="tree-chevron ${isExpanded ? 'expanded' : ''}" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"/></svg>`;
    
    const folderIcon = `<svg class="tree-icon" width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M10 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/></svg>`;
    
    const fileIcon = `<svg class="tree-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6z"/><path d="M14 2v6h6"/></svg>`;
    
    // Build the item
    let html = '';
    
    if (isFolder) {
      html = `
        <li class="tree-item tree-folder ${isExpanded ? 'expanded' : ''}" 
            style="padding-left: ${indent}px"
            onclick="event.stopPropagation(); toggleFolder('${node.path}')">
          ${chevronIcon}
          ${folderIcon}
          <span class="tree-name">${displayName}</span>
        </li>`;
      
      // Render children if expanded
      if (isExpanded && node.children.length > 0) {
        for (const child of node.children) {
          html += renderTreeNode(child, depth + 1);
        }
      }
    } else {
      // Files need extra indent to align with folder names (chevron width = 14px)
      const fileIndent = indent + 17;
      html = `
        <li class="tree-item tree-file ${isActive ? 'active' : ''}"
            style="padding-left: ${fileIndent}px"
            onclick="event.stopPropagation(); switchToFile('${node.path}')">
          ${fileIcon}
          <span class="tree-name">${displayName}</span>
        </li>`;
    }
    
    return html;
  }
  
  /**
   * Toggle folder expansion state
   */
  function toggleFolder(path) {
    if (expandedFolders.has(path)) {
      expandedFolders.delete(path);
    } else {
      expandedFolders.add(path);
    }
    renderFileTree();
  }
  
  /**
   * Expand all parent folders of a file path
   */
  function expandParentFolders(filePath) {
    const parts = filePath.split('/');
    let pathSoFar = '';
    
    // Expand all folders in the path (except the file itself)
    for (let i = 0; i < parts.length - 1; i++) {
      pathSoFar = pathSoFar ? `${pathSoFar}/${parts[i]}` : parts[i];
      expandedFolders.add(pathSoFar);
    }
  }
  
  // Make toggleFolder available globally
  window.toggleFolder = toggleFolder;

  function renderFileTree() {
    const container = document.getElementById("file-tree-container");
    const treeEl = document.getElementById("file-tree");
    
    if (!currentProject || !currentProjectFiles) {
      container.classList.add("hidden");
      return;
    }
    
    container.classList.remove("hidden");
    
    if (currentFile) {
      expandParentFolders(currentFile);
    }
    
    const filePaths = Object.keys(currentProjectFiles);
    const tree = buildFileTree(filePaths);
    
    let html = '<ul class="tree-list">';
    for (const child of tree.children) {
      html += renderTreeNode(child);
    }
    html += '</ul>';
    
    treeEl.innerHTML = html;
  }

  function switchToFile(fileName) {
    if (!currentProjectFiles[fileName]) return;
    
    // Save current file content
    if (currentFile && editor) {
      currentProjectFiles[currentFile] = editor.getValue();
    }
    
    // Switch to new file
    currentFile = fileName;
    editor.setValue(currentProjectFiles[fileName]);
    // Show just the filename in the indicator
    const displayName = fileName.split('/').pop();
    document.getElementById("file-indicator").textContent = displayName;
    
    // Update URL with current file
    updateURL(currentProject, fileName);
    
    // Update file tree
    renderFileTree();
    
    // Update diagnostics display for this file
    if (projectValidationResult && projectValidationResult.fileResults[fileName]) {
      const fileResult = projectValidationResult.fileResults[fileName];
      renderDiagnostics(fileResult.diagnostics);
      updateCounts(fileResult.metadata, fileResult.dependencies);
      // Re-render graph to highlight current file
      renderProjectGraph(projectValidationResult.unifiedGraph);
    }
  }

  function switchToProject(projectId, initialFile = null) {
    const project = projects[projectId];
    if (!project) return;
    
    // Save current file content before switching
    if (currentFile && editor) {
      currentProjectFiles[currentFile] = editor.getValue();
    }
    
    // Clear expanded folders for the new project
    expandedFolders.clear();
    
    // Switch to new project
    currentProject = projectId;
    currentProjectFiles = { ...project.files };
    
    // Load specified file or first file
    const fileNames = Object.keys(currentProjectFiles);
    currentFile = (initialFile && currentProjectFiles[initialFile]) ? initialFile : fileNames[0];
    editor.setValue(currentProjectFiles[currentFile]);
    // Show just the filename in the indicator
    const displayName = currentFile.split('/').pop();
    document.getElementById("file-indicator").textContent = displayName;
    
    // Update URL with project and file
    updateURL(projectId, currentFile);
    
    // Update UI
    renderProjectList();
    renderFileTree();
    
    // Sync mobile selector
    const mobileSelect = document.getElementById("scenario-mobile");
    if (mobileSelect) mobileSelect.value = `project:${projectId}`;
    
    // Validate entire project
    validateProject(currentProjectFiles);
  }

  // Make switchToFile and switchToProject available globally for onclick handlers
  window.switchToFile = switchToFile;
  window.switchToProject = switchToProject;

  // URL state management for permalinks
  function getURLParams() {
    const params = new URLSearchParams(window.location.search);
    return {
      project: params.get('project'),
      file: params.get('file'),
    };
  }

  function updateURL(projectId, fileName) {
    const url = new URL(window.location.href);
    if (projectId) {
      url.searchParams.set('project', projectId);
    }
    if (fileName) {
      url.searchParams.set('file', fileName);
    } else {
      url.searchParams.delete('file');
    }
    history.replaceState({}, '', url);
  }

  // Monaco setup
  require.config({
    paths: { vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs" },
  });

  require(["vs/editor/editor.main"], function () {
    // Register zen language
    monaco.languages.register({ id: "zen" });

    // -- MDZ_MONARCH_START
    monaco.languages.setMonarchTokensProvider("zen", {
      tokenizer: {
        root: [
          [/^```.*$/, { token: "markup.fenced_code", next: "@codeblock" }],
          [/^---$/, "meta.frontmatter"],
          [/^#+\s+.*$/, "markup.heading"],
          [/`[^`]*`/, "string"],
          [
            /^(\s*)(?:(ASYNC|AWAIT)\s+)?(DELEGATE)(\s+)([^\n]+?)(?=\s+TO\b|\s+WITH\b|\s*:?$)/,
            ["", "keyword", "keyword", "", "string.semantic"],
          ],
          [
            /^(\s*)(USE|EXECUTE)(\s+)(?:[^\n]*?\bTO\b\s+)([^\n:]+)/,
            ["", "keyword", "", "string.semantic"],
          ],
          [/^(\s*)(DO)(\s+)(.+)$/, ["", "keyword", "", "string.semantic"]],
          [
            /^(\s*)(IF|WHILE)(\s+)([^\n]+?)(?=\s+(?:THEN|DO)\b)/,
            ["", "keyword", "", "string.semantic"],
          ],
          [
            /^\s*(ELSE IF|ELSE|IF|FOR|WHILE|DO|END|RETURN|BREAK|CONTINUE|ASYNC|AWAIT|DELEGATE|USE|EXECUTE|GOTO)\b/,
            "keyword",
          ],
          [/\b(THEN|IN|AND|OR|NOT|WITH|TO)\b/, "keyword"],
          [/<</, "keyword.operator"],
          [/\$\/[^\/]+\//, "variable.inferred"],
          [/~\/[a-zA-Z0-9\/_-]+/, "entity.reference"],
          [/#[a-zA-Z][a-zA-Z0-9_-]*/, "entity.reference"],
          [/\$[A-Z][a-zA-Z0-9]*/, "type"],
          [/\$[a-z][a-zA-Z0-9-]*/, "variable"],
          [/"[^"]*"/, "string"],
          [/-?\d+(\.\d+)?/, "number"],
          [/<!--[\s\S]*?-->/, "comment"],
          [/^>.*$/, "comment"],
        ],
        codeblock: [
          [/^```.*$/, { token: "markup.fenced_code", next: "@pop" }],
          [/.*$/, "markup.fenced_code"],
        ],
      },
    });
    // -- MDZ_MONARCH_END

    // Theme
    monaco.editor.defineTheme("zen-dark", {
      base: "vs-dark",
      inherit: true,
      rules: [
        { token: "meta.frontmatter", foreground: "6A737D" },
        { token: "markup.heading", foreground: "E5E5E5", fontStyle: "bold" },
        { token: "keyword", foreground: "8B5CF6", fontStyle: "bold" },
        { token: "type", foreground: "06B6D4" },
        { token: "variable", foreground: "F59E0B" },
        { token: "string", foreground: "22C55E" },
        { token: "string.semantic", foreground: "EC4899", fontStyle: "italic" },
        { token: "variable.inferred", foreground: "EC4899" },
        { token: "entity.reference", foreground: "3B82F6" },
        { token: "delimiter.semantic", foreground: "EC4899" },
        { token: "variable.semantic", foreground: "F59E0B" },
        { token: "delimiter.reference", foreground: "3B82F6" },
        { token: "number", foreground: "F59E0B" },
        { token: "comment", foreground: "6A737D", fontStyle: "italic" },
      ],
      colors: {
        "editor.background": "#0A0A0A",
        "editor.foreground": "#EDEDED",
      },
    });

    monaco.editor.defineTheme("zen-light", {
      base: "vs",
      inherit: true,
      rules: [
        { token: "meta.frontmatter", foreground: "6A737D" },
        { token: "markup.heading", foreground: "171717", fontStyle: "bold" },
        { token: "keyword", foreground: "7C3AED", fontStyle: "bold" },
        { token: "type", foreground: "0891B2" },
        { token: "variable", foreground: "D97706" },
        { token: "string", foreground: "16A34A" },
        { token: "string.semantic", foreground: "DB2777", fontStyle: "italic" },
        { token: "variable.inferred", foreground: "DB2777" },
        { token: "entity.reference", foreground: "2563EB" },
        { token: "delimiter.semantic", foreground: "DB2777" },
        { token: "variable.semantic", foreground: "D97706" },
        { token: "delimiter.reference", foreground: "2563EB" },
        { token: "number", foreground: "D97706" },
        { token: "comment", foreground: "6B7280", fontStyle: "italic" },
      ],
      colors: {
        "editor.background": "#FAFAFA",
        "editor.foreground": "#171717",
      },
    });

    // Autocomplete provider for zen language
    monaco.languages.registerCompletionItemProvider("zen", {
      triggerCharacters: ["$", "~", "#", "/"],

      provideCompletionItems: (model, position) => {
        const textUntilPosition = model.getValueInRange({
          startLineNumber: 1,
          startColumn: 1,
          endLineNumber: position.lineNumber,
          endColumn: position.column,
        });

        const lineContent = model.getLineContent(position.lineNumber);
        const lineUntilPosition = lineContent.substring(0, position.column - 1);

        const suggestions = [];
        const fullText = model.getValue();

        // Check if we're completing after $ (types and variables)
        if (lineUntilPosition.match(/\$[a-zA-Z]*$/)) {
          // Extract types: $TypeName: ...
          const typeMatches = fullText.matchAll(/\$([A-Z][a-zA-Z0-9]*)\s*:/g);
          for (const match of typeMatches) {
            suggestions.push({
              label: "$" + match[1],
              kind: monaco.languages.CompletionItemKind.Class,
              insertText: match[1],
              detail: "Type",
              documentation: "Defined type",
            });
          }

          // Extract variables: $varName: $Type or $varName = ...
          const varMatches = fullText.matchAll(
            /\$([a-z][a-zA-Z0-9-]*)\s*[=:]/g,
          );
          const seenVars = new Set();
          for (const match of varMatches) {
            if (!seenVars.has(match[1])) {
              seenVars.add(match[1]);
              suggestions.push({
                label: "$" + match[1],
                kind: monaco.languages.CompletionItemKind.Variable,
                insertText: match[1],
                detail: "Variable",
                documentation: "Defined variable",
              });
            }
          }

          // Add built-in types
          const builtInTypes = [
            "String",
            "Number",
            "Boolean",
            "Array",
            "Object",
            "Any",
          ];
          for (const type of builtInTypes) {
            suggestions.push({
              label: "$" + type,
              kind: monaco.languages.CompletionItemKind.Class,
              insertText: type,
              detail: "Built-in type",
              documentation: "Built-in MDZ type",
            });
          }
        }

        // Check if we're completing a link path (after ~/)
        const linkMatch = lineUntilPosition.match(/~\/([a-z\/]*)$/);
        if (linkMatch) {
          const partial = linkMatch[1];
          // Suggest agent/skill/tool paths
          const paths = ["agent/", "skill/", "tool/"];
          for (const p of paths) {
            if (p.startsWith(partial) || partial.startsWith(p.slice(0, -1))) {
              suggestions.push({
                label: "~/" + p,
                kind: monaco.languages.CompletionItemKind.Folder,
                insertText: p.slice(partial.length),
                detail:
                  p.slice(0, -1).charAt(0).toUpperCase() +
                  p.slice(0, -1).slice(1) +
                  " path",
              });
            }
          }

          // Also suggest declared dependencies as full paths
          const usesMatch = fullText.match(
            /uses:\s*\n((?:\s+-\s+\S+\s*\n?)*)/,
          );
          if (usesMatch) {
            const depMatches = usesMatch[1].matchAll(/-\s+~\/(\S+)/g);
            for (const match of depMatches) {
              const depPath = match[1];
              if (depPath.startsWith(partial)) {
                suggestions.push({
                  label: "~/" + depPath,
                  kind: monaco.languages.CompletionItemKind.Module,
                  insertText: depPath.slice(partial.length),
                  detail: "Declared dependency",
                  documentation: "Declared in uses:",
                });
              }
            }
          }
        }

        // Check if we're completing an anchor (after #)
        const anchorMatch = lineUntilPosition.match(/#([a-z-]*)$/);
        if (anchorMatch && !lineUntilPosition.match(/~\/[^\s]*#/)) {
          // Same-file section completion
          const sectionMatches = fullText.matchAll(/^##\s+(.+)$/gm);
          for (const match of sectionMatches) {
            const sectionName = match[1].trim();
            const sectionId = sectionName
              .toLowerCase()
              .replace(/\s+/g, "-")
              .replace(/[^a-z0-9-]/g, "");
            suggestions.push({
              label: "#" + sectionId,
              kind: monaco.languages.CompletionItemKind.Reference,
              insertText: sectionId,
              detail: "Section: " + sectionName,
            });
          }
        }

        return { suggestions };
      },
    });

    const semanticTokenLegend = {
      tokenTypes: [
        "keyword",
        "variable",
        "type",
        "string",
        "number",
        "operator",
        "function",
        "parameter",
        "namespace",
        "semanticSpan",
        "link",
        "anchor",
      ],
      tokenModifiers: [],
    };

    monaco.languages.registerDocumentSemanticTokensProvider("zen", {
      getLegend: () => semanticTokenLegend,
      provideDocumentSemanticTokens: async (model) => {
        const result = await sendToWorker("semanticTokens", {
          uri: model.uri.toString(),
          source: model.getValue(),
        });
        return {
          data: new Uint32Array(result.data),
        };
      },
      releaseDocumentSemanticTokens: () => {},
    });

    const isDark = window.matchMedia("(prefers-color-scheme: dark)").matches;

    // Read URL parameters for permalink support
    const urlParams = getURLParams();
    const projectIds = Object.keys(projects);
    
    // Determine which project to load (from URL or default)
    let initialProjectId = urlParams.project && projects[urlParams.project] 
      ? urlParams.project 
      : projectIds.find(id => Object.keys(projects[id].files).length > 0) || projectIds[0];
    
    const initialProject = projects[initialProjectId];
    currentProject = initialProjectId;
    currentProjectFiles = { ...initialProject.files };
    
    // Determine which file to load (from URL or default)
    const fileNames = Object.keys(currentProjectFiles);
    currentFile = (urlParams.file && currentProjectFiles[urlParams.file]) 
      ? urlParams.file 
      : fileNames[0];
    
    // Update URL to reflect actual loaded state (normalizes URL)
    updateURL(currentProject, currentFile);

    editor = monaco.editor.create(document.getElementById("editor"), {
      value: currentProjectFiles[currentFile],
      language: "zen",
      theme: isDark ? "zen-dark" : "zen-light",
      fontSize: 14,
      fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
      minimap: { enabled: false },
      lineNumbers: "on",
      scrollBeyondLastLine: false,
      automaticLayout: true,
      padding: { top: 16, bottom: 16 },
      wordWrap: "on",
      readOnly: false,
    });

    // Position tracking
    editor.onDidChangeCursorPosition((e) => {
      document.getElementById("position").textContent =
        `Line ${e.position.lineNumber}, Col ${e.position.column}`;
    });

    // Content change tracking with debounce
    editor.onDidChangeModelContent(() => {
      if (validateTimeout) {
        clearTimeout(validateTimeout);
      }
      validateTimeout = setTimeout(() => {
        const source = editor.getValue();
        
        // Always in project mode now - update the file and validate whole project
        if (currentProject && currentFile) {
          currentProjectFiles[currentFile] = source;
          validateProject(currentProjectFiles);
        }
      }, 300);
    });

    // Initialize worker and run initial validation
    initWorker();
    document.getElementById("file-indicator").textContent = currentFile.split('/').pop();
    
    // Render project list and file tree
    renderProjectList();
    renderFileTree();

    // Wait for worker to be ready, then validate project
    setTimeout(() => {
      validateProject(currentProjectFiles);
    }, 100);

    // Handle mobile project selection
    document.getElementById("scenario-mobile").addEventListener("change", (e) => {
      const projectId = e.target.value.replace("project:", "");
      switchToProject(projectId);
    });

    // Theme changes
    window
      .matchMedia("(prefers-color-scheme: dark)")
      .addEventListener("change", (e) => {
        monaco.editor.setTheme(e.matches ? "zen-dark" : "zen-light");
      });

    // Make jumpToLine available globally
    window.jumpToLine = function (line, column = 1) {
      if (editor) {
        editor.revealLineInCenter(line);
        editor.setPosition({ lineNumber: line, column: column });
        editor.focus();
      }
    };
  });
</script>
