---
import Layout from '../layouts/Layout.astro';
import Header from '../components/Header.astro';
---

<Layout title="Playground - zen">
  <Header currentPath="/playground" />
  
  <div class="h-[calc(100vh-4rem)] flex flex-col">
    <!-- Toolbar -->
    <div class="flex items-center justify-between px-4 py-2 border-b border-[var(--color-border)] dark:border-[var(--color-border-dark)] bg-[var(--color-bg)] dark:bg-[var(--color-bg-dark)]">
      <div class="flex items-center gap-4">
        <!-- Examples dropdown -->
        <select id="examples" class="text-sm bg-transparent border border-[var(--color-border)] dark:border-[var(--color-border-dark)] rounded px-3 py-1.5 text-[var(--color-text)] dark:text-[var(--color-text-dark)]">
          <option value="">Select an example...</option>
          <option value="hello">Hello World</option>
          <option value="scientist">The Scientist</option>
          <option value="debugger">Debugger</option>
        </select>
        
        <!-- Options -->
        <div class="flex items-center gap-3 text-sm">
          <label class="flex items-center gap-1.5 text-[var(--color-muted)] dark:text-[var(--color-muted-dark)]">
            <input type="checkbox" id="expandTypes" checked class="rounded">
            Expand types
          </label>
          <label class="flex items-center gap-1.5 text-[var(--color-muted)] dark:text-[var(--color-muted-dark)]">
            <input type="checkbox" id="transformSemantics" checked class="rounded">
            Transform semantics
          </label>
          <label class="flex items-center gap-1.5 text-[var(--color-muted)] dark:text-[var(--color-muted-dark)]">
            <input type="checkbox" id="resolveRefs" checked class="rounded">
            Resolve refs
          </label>
        </div>
      </div>
      
      <div class="flex items-center gap-2">
        <button id="share" class="text-sm px-3 py-1.5 text-[var(--color-muted)] dark:text-[var(--color-muted-dark)] hover:text-[var(--color-text)] dark:hover:text-[var(--color-text-dark)] transition-colors">
          Share
        </button>
        <button id="copy" class="text-sm px-3 py-1.5 bg-[var(--color-accent)] text-white rounded hover:bg-[var(--color-accent-light)] transition-colors">
          Copy Output
        </button>
      </div>
    </div>
    
    <!-- Editor panels -->
    <div class="flex-1 flex">
      <!-- Source editor -->
      <div class="flex-1 flex flex-col border-r border-[var(--color-border)] dark:border-[var(--color-border-dark)]">
        <div class="px-4 py-2 text-xs font-medium text-[var(--color-muted)] dark:text-[var(--color-muted-dark)] uppercase tracking-wide border-b border-[var(--color-border)] dark:border-[var(--color-border-dark)]">
          Source
        </div>
        <div id="editor" class="flex-1"></div>
      </div>
      
      <!-- Output panel -->
      <div class="flex-1 flex flex-col">
        <div class="px-4 py-2 text-xs font-medium text-[var(--color-muted)] dark:text-[var(--color-muted-dark)] uppercase tracking-wide border-b border-[var(--color-border)] dark:border-[var(--color-border-dark)]">
          Compiled Output
        </div>
        <div id="output" class="flex-1"></div>
      </div>
    </div>
    
    <!-- Status bar -->
    <div class="flex items-center justify-between px-4 py-1.5 text-xs border-t border-[var(--color-border)] dark:border-[var(--color-border-dark)] bg-[var(--color-bg)] dark:bg-[var(--color-bg-dark)] text-[var(--color-muted)] dark:text-[var(--color-muted-dark)]">
      <div class="flex items-center gap-4">
        <span id="errors">Errors: 0</span>
        <span id="stats"></span>
      </div>
      <div id="position">Line 1, Col 1</div>
    </div>
  </div>
</Layout>

<!-- Load Monaco from CDN -->
<script is:inline src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>

<script type="module">
  // Import the zen compiler
  import { compile as zenCompile, parse as zenParse } from '/zen-compiler.js';

  // Initialize WebWorker for LSP features
  const worker = new Worker('/zen-worker.js');
  let requestId = 0;
  const pendingRequests = new Map();

  // Promise-based wrapper for worker requests
  function sendWorkerRequest(type, params) {
    return new Promise((resolve, reject) => {
      const id = ++requestId;
      pendingRequests.set(id, { resolve, reject });
      worker.postMessage({ type, id, ...params });

      // Timeout after 5 seconds
      setTimeout(() => {
        if (pendingRequests.has(id)) {
          pendingRequests.delete(id);
          reject(new Error(`Worker request timeout: ${type}`));
        }
      }, 5000);
    });
  }

  // Handle worker responses
  worker.onmessage = (event) => {
    const { type, id, result, error } = event.data;
    const pending = pendingRequests.get(id);

    if (pending) {
      pendingRequests.delete(id);
      if (error) {
        pending.reject(new Error(error));
      } else {
        pending.resolve(result);
      }
    }
  };

  worker.onerror = (error) => {
    console.error('Worker error:', error);
  };

  // Default example
  const defaultSource = `---
name: hello-world
description: When you want to get started with zen
---

## Types

$Greeting = a friendly greeting message
$Tone = "formal" | "casual" | "enthusiastic"

## Input

- $name: $String = "World"
- $tone: $Tone = "casual"

## Workflow

1. Create a $Greeting for $name
2. Make it {~~appropriately warm for the tone}
3. IF $tone = "enthusiastic" THEN:
   - Add extra exclamation marks
4. Return the greeting
`;

  const examples = {
    hello: defaultSource,
    scientist: `---
name: the-scientist
description: When orchestrating hypothesis-driven iteration
uses:
  - work-packages
---

## Types

$Hypothesis = a testable prediction
$Result = "confirmed" | "refuted" | "inconclusive"

## Input

- $problem: $String
- $maxIterations: $Number = 5

## Context

- $currentHypothesis: $Hypothesis
- $iteration = 0

## Workflow

WHILE (NOT diminishing returns AND $iteration < $maxIterations):
  - Formulate $currentHypothesis
  - Design experiment to test it
  - Delegate to [[#experiment-prompt]]
  - IF $result = "confirmed" THEN:
    - Commit changes
    - Update hypothesis
  - ELSE:
    - Record what didn't work
  - Increment $iteration

## Experiment Prompt

Run the experiment precisely and report observations.
`,
    debugger: `---
name: debugger
description: When you need to trace skill execution
---

## Types

$TraceLevel = "minimal" | "verbose" | "debug"
$TraceEvent = a record of something during execution

## Input

- $skill: $String
- $traceLevel: $TraceLevel = "verbose"

## Workflow

FOR EACH $statement IN $skill.statements:
  - Log entry: {~~formatted statement preview}
  - IF $traceLevel = "debug" THEN:
    - Log all variable values
  - Execute statement
  - Log exit with duration

Generate trace summary at {~~appropriate location}
`,
  };

  // Monaco configuration
  require.config({ 
    paths: { 
      vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' 
    }
  });

  require(['vs/editor/editor.main'], function() {
    // Register zen language
    monaco.languages.register({ id: 'zen' });
    
    // Tokenizer based on TextMate grammar
    monaco.languages.setMonarchTokensProvider('zen', {
      tokenizer: {
        root: [
          // Frontmatter
          [/^---$/, 'meta.frontmatter'],
          
          // Headings
          [/^#+\s+.*$/, 'markup.heading'],
          
          // Control flow keywords
          [/\b(PARALLEL FOR EACH|FOR EACH|WHILE|IF|THEN|ELSE|IN|AND|OR|NOT|WITH|BREAK|CONTINUE)\b/, 'keyword'],
          
          // Semantic markers
          [/\{~~/, { token: 'delimiter.semantic', next: '@semantic' }],
          
          // References
          [/\[\[/, { token: 'delimiter.reference', next: '@reference' }],
          
          // Types ($UpperCase)
          [/\$[A-Z][a-zA-Z0-9]*/, 'type'],
          
          // Variables ($lowerCase)
          [/\$[a-z][a-zA-Z0-9-]*/, 'variable'],
          
          // Strings
          [/"[^"]*"/, 'string'],
          
          // Template literals
          [/`/, { token: 'string.template', next: '@template' }],
          
          // Numbers
          [/-?\d+(\.\d+)?/, 'number'],
          
          // Operators
          [/=>/, 'operator.arrow'],
          [/[=!<>]=?/, 'operator'],
          [/\|/, 'operator.pipe'],
          
          // Comments (blockquotes)
          [/^>.*$/, 'comment'],
        ],
        
        semantic: [
          [/[^}]+/, 'string.semantic'],
          [/\}/, { token: 'delimiter.semantic', next: '@pop' }],
        ],
        
        reference: [
          [/[^\]]+/, 'entity.reference'],
          [/\]\]/, { token: 'delimiter.reference', next: '@pop' }],
        ],
        
        template: [
          [/\$\{[^}]*\}/, 'variable.interpolated'],
          [/\{~~[^}]*\}/, 'string.semantic'],
          [/[^`$\{]+/, 'string.template'],
          [/`/, { token: 'string.template', next: '@pop' }],
        ],
      },
    });

    // Define theme
    monaco.editor.defineTheme('zen-dark', {
      base: 'vs-dark',
      inherit: true,
      rules: [
        { token: 'meta.frontmatter', foreground: '6A737D' },
        { token: 'markup.heading', foreground: 'E5E5E5', fontStyle: 'bold' },
        { token: 'keyword', foreground: '8B5CF6', fontStyle: 'bold' },
        { token: 'type', foreground: '06B6D4' },
        { token: 'variable', foreground: 'F59E0B' },
        { token: 'string', foreground: '22C55E' },
        { token: 'string.semantic', foreground: 'EC4899', fontStyle: 'italic' },
        { token: 'string.template', foreground: '22C55E' },
        { token: 'entity.reference', foreground: '3B82F6' },
        { token: 'delimiter.semantic', foreground: 'EC4899' },
        { token: 'delimiter.reference', foreground: '3B82F6' },
        { token: 'operator', foreground: 'A3A3A3' },
        { token: 'operator.arrow', foreground: '8B5CF6' },
        { token: 'operator.pipe', foreground: '8B5CF6' },
        { token: 'number', foreground: 'F59E0B' },
        { token: 'comment', foreground: '6A737D', fontStyle: 'italic' },
      ],
      colors: {
        'editor.background': '#0A0A0A',
        'editor.foreground': '#EDEDED',
        'editorLineNumber.foreground': '#4B5563',
        'editorCursor.foreground': '#6366F1',
        'editor.selectionBackground': '#6366F140',
      },
    });

    // Light theme
    monaco.editor.defineTheme('zen-light', {
      base: 'vs',
      inherit: true,
      rules: [
        { token: 'meta.frontmatter', foreground: '6A737D' },
        { token: 'markup.heading', foreground: '171717', fontStyle: 'bold' },
        { token: 'keyword', foreground: '7C3AED', fontStyle: 'bold' },
        { token: 'type', foreground: '0891B2' },
        { token: 'variable', foreground: 'D97706' },
        { token: 'string', foreground: '16A34A' },
        { token: 'string.semantic', foreground: 'DB2777', fontStyle: 'italic' },
        { token: 'entity.reference', foreground: '2563EB' },
        { token: 'delimiter.semantic', foreground: 'DB2777' },
        { token: 'delimiter.reference', foreground: '2563EB' },
        { token: 'number', foreground: 'D97706' },
        { token: 'comment', foreground: '6B7280', fontStyle: 'italic' },
      ],
      colors: {
        'editor.background': '#FAFAFA',
        'editor.foreground': '#171717',
        'editorLineNumber.foreground': '#9CA3AF',
        'editorCursor.foreground': '#6366F1',
        'editor.selectionBackground': '#6366F130',
      },
    });

    // Detect dark mode
    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

    // Create source editor
    const editor = monaco.editor.create(document.getElementById('editor'), {
      value: defaultSource,
      language: 'zen',
      theme: isDark ? 'zen-dark' : 'zen-light',
      fontSize: 14,
      fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
      minimap: { enabled: false },
      lineNumbers: 'on',
      scrollBeyondLastLine: false,
      automaticLayout: true,
      padding: { top: 16, bottom: 16 },
      wordWrap: 'on',
    });

    // LSP to Monaco type conversions
    function lspToMonacoPosition(line, character) {
      // LSP is 0-based line and character, Monaco is 1-based
      return { lineNumber: line + 1, column: character + 1 };
    }

    function monacoToLspPosition(position) {
      // Monaco is 1-based, LSP is 0-based
      return { line: position.lineNumber - 1, character: position.column - 1 };
    }

    function lspCompletionKindToMonaco(kind) {
      const kindMap = {
        'text': monaco.languages.CompletionItemKind.Text,
        'method': monaco.languages.CompletionItemKind.Method,
        'function': monaco.languages.CompletionItemKind.Function,
        'constructor': monaco.languages.CompletionItemKind.Constructor,
        'field': monaco.languages.CompletionItemKind.Field,
        'variable': monaco.languages.CompletionItemKind.Variable,
        'class': monaco.languages.CompletionItemKind.Class,
        'interface': monaco.languages.CompletionItemKind.Interface,
        'module': monaco.languages.CompletionItemKind.Module,
        'property': monaco.languages.CompletionItemKind.Property,
        'unit': monaco.languages.CompletionItemKind.Unit,
        'value': monaco.languages.CompletionItemKind.Value,
        'enum': monaco.languages.CompletionItemKind.Enum,
        'keyword': monaco.languages.CompletionItemKind.Keyword,
        'snippet': monaco.languages.CompletionItemKind.Snippet,
        'color': monaco.languages.CompletionItemKind.Color,
        'reference': monaco.languages.CompletionItemKind.Reference,
        'file': monaco.languages.CompletionItemKind.File,
        'folder': monaco.languages.CompletionItemKind.Folder,
        'enumMember': monaco.languages.CompletionItemKind.EnumMember,
        'constant': monaco.languages.CompletionItemKind.Constant,
        'struct': monaco.languages.CompletionItemKind.Struct,
        'event': monaco.languages.CompletionItemKind.Event,
        'operator': monaco.languages.CompletionItemKind.Operator,
        'typeParameter': monaco.languages.CompletionItemKind.TypeParameter,
      };
      return kindMap[kind] || monaco.languages.CompletionItemKind.Text;
    }

    function lspDiagnosticSeverityToMonaco(severity) {
      const severityMap = {
        'error': monaco.MarkerSeverity.Error,
        'warning': monaco.MarkerSeverity.Warning,
        'info': monaco.MarkerSeverity.Info,
        'hint': monaco.MarkerSeverity.Hint,
      };
      return severityMap[severity] || monaco.MarkerSeverity.Error;
    }

    // Register completion provider
    monaco.languages.registerCompletionItemProvider('zen', {
      triggerCharacters: ['[', '$'],
      provideCompletionItems: async (model, position) => {
        try {
          const source = model.getValue();
          const uri = model.uri.toString();
          const lspPos = monacoToLspPosition(position);

          const result = await sendWorkerRequest('completions', {
            uri,
            source,
            position: lspPos,
          });

          if (!result || !Array.isArray(result)) {
            return { suggestions: [] };
          }

          const suggestions = result.map(item => {
            const monacoItem = {
              label: item.label,
              kind: lspCompletionKindToMonaco(item.kind || 'text'),
              insertText: item.insertText || item.label,
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              documentation: item.documentation,
              detail: item.detail,
              sortText: item.sortText,
              filterText: item.filterText,
            };

            // Add range if provided
            if (item.range) {
              monacoItem.range = {
                startLineNumber: item.range.start.line + 1,
                startColumn: item.range.start.character + 1,
                endLineNumber: item.range.end.line + 1,
                endColumn: item.range.end.character + 1,
              };
            }

            return monacoItem;
          });

          return { suggestions };
        } catch (error) {
          console.error('Completion error:', error);
          return { suggestions: [] };
        }
      },
    });

    // Register hover provider
    monaco.languages.registerHoverProvider('zen', {
      provideHover: async (model, position) => {
        try {
          const source = model.getValue();
          const uri = model.uri.toString();
          const lspPos = monacoToLspPosition(position);

          const result = await sendWorkerRequest('hover', {
            uri,
            source,
            position: lspPos,
          });

          if (!result || !result.contents) {
            return null;
          }

          const hover = {
            contents: Array.isArray(result.contents)
              ? result.contents.map(c => ({ value: typeof c === 'string' ? c : c.value }))
              : [{ value: typeof result.contents === 'string' ? result.contents : result.contents.value }],
          };

          if (result.range) {
            hover.range = {
              startLineNumber: result.range.start.line + 1,
              startColumn: result.range.start.character + 1,
              endLineNumber: result.range.end.line + 1,
              endColumn: result.range.end.character + 1,
            };
          }

          return hover;
        } catch (error) {
          console.error('Hover error:', error);
          return null;
        }
      },
    });

    // Diagnostics with debouncing
    let diagnosticsTimeout;
    async function updateDiagnostics() {
      clearTimeout(diagnosticsTimeout);
      diagnosticsTimeout = setTimeout(async () => {
        try {
          const source = editor.getValue();
          const uri = editor.getModel().uri.toString();

          const result = await sendWorkerRequest('diagnostics', {
            uri,
            source,
          });

          if (!result || !Array.isArray(result)) {
            return;
          }

          const markers = result.map(diagnostic => ({
            severity: lspDiagnosticSeverityToMonaco(diagnostic.severity || 'error'),
            startLineNumber: diagnostic.range.start.line + 1,
            startColumn: diagnostic.range.start.character + 1,
            endLineNumber: diagnostic.range.end.line + 1,
            endColumn: diagnostic.range.end.character + 1,
            message: diagnostic.message,
            source: diagnostic.source || 'zen',
            code: diagnostic.code,
          }));

          monaco.editor.setModelMarkers(editor.getModel(), 'zen', markers);
        } catch (error) {
          console.error('Diagnostics error:', error);
        }
      }, 150);
    }

    // Create output viewer
    const output = monaco.editor.create(document.getElementById('output'), {
      value: '',
      language: 'markdown',
      theme: isDark ? 'zen-dark' : 'zen-light',
      fontSize: 14,
      fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
      minimap: { enabled: false },
      lineNumbers: 'on',
      scrollBeyondLastLine: false,
      automaticLayout: true,
      readOnly: true,
      padding: { top: 16, bottom: 16 },
      wordWrap: 'on',
    });

    // Compile function using real zen compiler
    function compile(source) {
      const expandTypes = document.getElementById('expandTypes').checked;
      const transformSemantics = document.getElementById('transformSemantics').checked;
      const resolveRefs = document.getElementById('resolveRefs').checked;
      
      try {
        const result = zenCompile(source, {
          expandTypes,
          transformSemantics,
          resolveReferences: resolveRefs,
          includeHeader: true,
          generateSourceMap: true,
          inlineSkills: false,
        });
        
        return {
          output: result.output,
          stats: result.stats,
          errors: result.diagnostics.filter(d => d.severity === 'error'),
          warnings: result.diagnostics.filter(d => d.severity === 'warning'),
        };
      } catch (err) {
        console.error('Compilation error:', err);
        return {
          output: `<!-- Compilation Error -->\n\n${err.message}\n\n<!-- Source -->\n${source}`,
          stats: {
            sourceLength: source.length,
            outputLength: 0,
            typesExpanded: 0,
            referencesResolved: 0,
            semanticMarkersTransformed: 0,
            controlFlowStatements: 0,
          },
          errors: [{ message: err.message, span: { start: { line: 1, column: 0 }, end: { line: 1, column: 0 } } }],
          warnings: [],
        };
      }
    }

    // Update output on change
    function updateOutput() {
      const source = editor.getValue();
      const result = compile(source);
      output.setValue(result.output);
      
      // Update stats
      const statsText = [
        `Types: ${result.stats.typesExpanded}`,
        `Refs: ${result.stats.referencesResolved}`,
        `Semantic: ${result.stats.semanticMarkersTransformed}`,
        `Control: ${result.stats.controlFlowStatements}`,
        `Chars: ${result.stats.sourceLength} â†’ ${result.stats.outputLength}`,
      ].join(' | ');
      
      document.getElementById('stats').textContent = statsText;
      
      const errorCount = result.errors.length;
      const warningCount = result.warnings?.length || 0;
      let errorsText = `Errors: ${errorCount}`;
      if (warningCount > 0) {
        errorsText += ` Warnings: ${warningCount}`;
      }
      document.getElementById('errors').textContent = errorsText;
      
      // Update error styling
      const errorsEl = document.getElementById('errors');
      if (errorCount > 0) {
        errorsEl.classList.add('text-red-500');
      } else {
        errorsEl.classList.remove('text-red-500');
      }
    }

    editor.onDidChangeModelContent(() => {
      updateOutput();
      updateDiagnostics();
    });
    document.getElementById('expandTypes').addEventListener('change', updateOutput);
    document.getElementById('transformSemantics').addEventListener('change', updateOutput);
    document.getElementById('resolveRefs').addEventListener('change', updateOutput);

    // Update position
    editor.onDidChangeCursorPosition((e) => {
      document.getElementById('position').textContent = 
        `Line ${e.position.lineNumber}, Col ${e.position.column}`;
    });

    // Example selector
    document.getElementById('examples').addEventListener('change', (e) => {
      if (e.target.value && examples[e.target.value]) {
        editor.setValue(examples[e.target.value]);
        updateDiagnostics();
      }
    });

    // Copy button
    document.getElementById('copy').addEventListener('click', () => {
      navigator.clipboard.writeText(output.getValue());
      const btn = document.getElementById('copy');
      btn.textContent = 'Copied!';
      setTimeout(() => btn.textContent = 'Copy Output', 2000);
    });

    // Share button
    document.getElementById('share').addEventListener('click', () => {
      const source = editor.getValue();
      const encoded = btoa(encodeURIComponent(source));
      const url = `${window.location.origin}/playground?code=${encoded}`;
      navigator.clipboard.writeText(url);
      const btn = document.getElementById('share');
      btn.textContent = 'URL Copied!';
      setTimeout(() => btn.textContent = 'Share', 2000);
    });

    // Load from URL if present
    const params = new URLSearchParams(window.location.search);
    const codeParam = params.get('code');
    if (codeParam) {
      try {
        const decoded = decodeURIComponent(atob(codeParam));
        editor.setValue(decoded);
      } catch (e) {
        console.error('Failed to decode URL parameter');
      }
    }

    // Initial compile and diagnostics
    updateOutput();
    updateDiagnostics();

    // Handle dark mode changes
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
      const theme = e.matches ? 'zen-dark' : 'zen-light';
      monaco.editor.setTheme(theme);
    });
  });
</script>
