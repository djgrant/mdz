Start = blocks:Blocks

Blocks
  = parts:TopBlock* tail:HostTail? {
      const out = parts;
      if (tail !== null) out.push(tail);
      return out;
    }

TopBlock
  = ForBlock
  / PushLine
  / AssignLine
  / StatementLine
  / HostBlock


/* --------- One-line Statment ------- */

StatementLine
  = MdZIndent kw:StatementKeyword rest:LineText? LineEnd {
      return {
        type: "stmt",
        keyword: kw,
        text: (rest ?? "").trim()
      };
    }

StatementStartLine
 = MdZIndent StatementKeyword

StatementKeyword
  = Kw_BREAK
  / Kw_CONTINUE
  / Kw_RETURN
  / Kw_DELEGATE
  / Kw_ASYNC
  / Kw_AWAIT
  / Kw_USE
  / Kw_GOTO


/* ---------- Inner blocks ---------- */

InnerBlocks =
  blocks:InnerBlock* {
    return blocks;
  }

InnerBlock =
  &NotEnd innerBlock:(
    ForBlock /
    PushLine /
    AssignLine /
    StatementLine /
    HostInnerBlock
  ) {
    return innerBlock;
  }

NotEnd = !EndLine

EndLine
  = MdZIndent "END" WordBoundary (Newline / End) {
  	return "END";
  }


/* ---------- Sigils ---------- */

BlockStartLine = MdZIndent Kw_FOR __ ExprUntilIn __ Kw_IN __


/* ---------- FOR Statement ---------- */

ForBlock
  = header:ForHeader inner:InnerBlocks EndLine {
      return {
        type: "for",
        target: header.target,
        iterable: header.iterable,
        blocks: inner
      };
    }

ForHeader
  = MdZIndent
    Kw_FOR __ target:ExprUntilIn __ Kw_IN __ iterable:LineText?
    Newline {
      return {
        target: target.trim(),
        iterable: (iterable ?? "").trim()
      };
    }

ExprUntilIn
  = $( ( !(__ Kw_IN) . )+ )


/* ---------- Host blocks ---------- */

HostBlock
  = lines:HostLineTop+ {
      return { type: "host", text: lines.join("") };
    }

HostInnerBlock
  = lines:HostLineInner+ {
      return { type: "host", text: lines.join("") };
    }

HostLineTop
  = !BlockStartLine
  	!PushStartLine
  	!AssignStartLine
  	!StatementStartLine
    !EndLine
    s:LineText?
    Newline {
    	return (s ?? "") + "\n";
}

HostLineInner
  = !BlockStartLine
    !PushStartLine
    !AssignStartLine
    !StatementStartLine
    !EndLine
    indent:$(Indent ListMarker?)
    line:LineText?
    Newline {
      return indent + (line ?? "") + "\n";
    }

HostTail
  = !BlockStartLine
    !PushStartLine
    !AssignStartLine
    !StatementStartLine
    !EndLine
    line:LineTextNonEmpty
    End {
      return { type: "host", text: line };
    }


/* ---------- Push ---------- */

PushLine
  = MdZIndent target:Var _ "<<" _ value:LineText? LineEnd {
      return {
        type: "push",
        target,
        value: (value ?? "").trim()
      };
    }

PushStartLine
  = MdZIndent Var _ "<<"


/* ---------- Assignments ---------- */

AssignLine
  = MdZIndent target:Var _ typeAnn:TypeAnnotation? _ "=" _ value:Value? LineEnd {
      return {
        type: "assign",
        target,
        ...(typeAnn ? { annotatedType: typeAnn } : {}),
        value: value ?? ""
      };
    }

AssignStartLine
  = MdZIndent Var _ (":" / "=")

TypeAnnotation
  = ":" _ typeText:TypeExprUntilEq {
      return typeText.trim();
    }

TypeExprUntilEq
  = $( ( !(_ "=") . )+ )

Value
  = ArrayLiteral
  / InferredValue
  / TemplateLiteral
  / LambdaValue
  / valueText:LineText { return valueText.trim(); }

ArrayLiteral
  = "[" _ elements:ArrayElements? _ "]" {
      return { type: "array", elements: elements ?? [] };
    }

ArrayElements
  = head:ArrayElement tail:(_ "," _ ArrayElement)* {
      return [head, ...tail.map(([, , , element]) => element)];
    }

ArrayElement
  = text:$( (!("," / "]") .)+ ) {
      return text.trim();
    }

InferredValue
  = "$/" text:$( (!"/" .)* ) "/" {
      return { type: "inferred", text };
    }

TemplateLiteral
  = "`" parts:TemplateParts "`" {
      return { type: "template", parts };
    }

TemplateParts
  = parts:TemplatePart* { return parts; }

TemplatePart
  = TemplateExpr
  / TemplateText

TemplateExpr
  = "${" name:Var "}" {
      return { type: "var", name };
    }

TemplateText
  = text:$( (!("`" / "${") .)+ ) {
      return text;
    }

LambdaValue
  = params:LambdaParams _ "=>" _ body:LineText? {
      return {
        type: "lambda",
        params,
        body: (body ?? "").trim()
      };
    }

LambdaParams
  = LambdaParamList
  / param:Var { return [param]; }

LambdaParamList
  = "(" _ head:Var tail:(_ "," _ Var)* _ ")" {
      return [head, ...tail.map(([, , , param]) => param)];
    }


/* ---------- Keywords ---------- */

Kw_FOR       = "FOR" WordBoundary { return "FOR" }
Kw_IN        = "IN" WordBoundary { return "IN" }
Kw_WHILE     = "WHILE" WordBoundary { return "WHILE" }
Kw_DO        = "DO" WordBoundary { return "DO" }
Kw_IF        = "IF" WordBoundary { return "IF" }
Kw_THEN      = "THEN" WordBoundary { return "THEN" }
Kw_ELSE      = "ELSE" WordBoundary { return "ELSE" }
Kw_AND       = "AND" WordBoundary { return "AND" }
Kw_OR        = "OR" WordBoundary { return "OR" }
Kw_NOT       = "NOT" WordBoundary { return "NOT" }
Kw_WITH      = "WITH" WordBoundary { return "WITH" }
Kw_BREAK     = "BREAK" WordBoundary { return "BREAK" }
Kw_CONTINUE  = "CONTINUE" WordBoundary { return "CONTINUE" }
Kw_RETURN    = "RETURN" WordBoundary { return "RETURN" }
Kw_DELEGATE  = "DELEGATE" WordBoundary { return "DELEGATE" }
Kw_TO        = "TO" WordBoundary { return "TO" }
Kw_ASYNC     = "ASYNC" WordBoundary { return "ASYNC" }
Kw_AWAIT     = "AWAIT" WordBoundary { return "AWAIT" }
Kw_USE       = "USE" WordBoundary { return "USE" }
Kw_GOTO      = "GOTO" WordBoundary { return "GOTO" }


/* ---------- Helpers ---------- */

Var = $("$" [a-zA-Z_][a-zA-Z0-9_]*)

Newline = "\r\n" / "\n"
End     = !.

WordBoundary = ![a-zA-Z0-9_-]

LineText         = $( (!Newline .)* )
LineTextNonEmpty = $( (!Newline .)+ )
LineEnd          = Newline / End

ListMarker = "-" [ \t]+
MdZIndent  = Indent ListMarker?
Indent     = [ \t]*
_          = [ \t]*
__         = [ \t]+
