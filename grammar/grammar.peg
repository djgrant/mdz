Start = blocks:Blocks

Blocks
  = parts:TopBlock* tail:HostTail? {
      const out = parts.filter((part) => part !== null);
      if (tail !== null) out.push(tail);
      return out;
    }

TopBlock
  = ForBlock
  / WhileBlock
  / IfBlock
  / DoBlock
  / DelegateBlock
  / UseBlock
  / PushLine
  / AssignLine
  / StatementLine
  / HostBlock


/* --------- One-line Statment ------- */

StatementLine
  = MdZIndent kw:StatementKeyword rest:LineText? LineEnd {
      return {
        type: "stmt",
        keyword: kw,
        text: (rest ?? "").trim()
      };
    }

StatementStartLine
 = MdZIndent StatementKeyword

StatementKeyword
  = Kw_BREAK
  / Kw_CONTINUE
  / Kw_RETURN
  / Kw_DELEGATE
  / Kw_ASYNC
  / Kw_AWAIT
  / Kw_USE
  / Kw_GOTO
  / Kw_DO


/* ---------- Inner blocks ---------- */

InnerBlocks =
  blocks:InnerBlock* {
    return blocks.filter((block) => block !== null);
  }

InnerBlock =
  &NotEnd innerBlock:(
    ForBlock /
    WhileBlock /
    IfBlock /
    DoBlock /
    DelegateBlock /
    UseBlock /
    PushLine /
    AssignLine /
    StatementLine /
    HostInnerBlock
  ) {
    return innerBlock;
  }

NotEnd = !EndLine

NotEndOrElse = !EndLine !ElseLine

EndLine
  = MdZIndent "END" WordBoundary (Newline / End) {
  	return "END";
  }


/* ---------- Sigils ---------- */

BlockStartLine
  = MdZIndent (
      Kw_FOR __ ExprUntilIn __ Kw_IN __ /
      Kw_WHILE __ ExprUntilDo __ Kw_DO /
      Kw_IF __ /
      Kw_DO
    )

ElseLine
  = MdZIndent Kw_ELSE WordBoundary (Newline / End) {
      return "ELSE";
    }


/* ---------- FOR Statement ---------- */

ForBlock
  = header:ForHeader inner:InnerBlocks EndLine {
      return {
        type: "for",
        target: header.target,
        iterable: header.iterable,
        blocks: inner
      };
    }

ForHeader
  = MdZIndent
    Kw_FOR __ target:ExprUntilIn __ Kw_IN __ iterable:LineText?
    Newline {
      return {
        target: target.trim(),
        iterable: (iterable ?? "").trim()
      };
    }

ExprUntilIn
  = $( ( !(__ Kw_IN) . )+ )

ExprUntilDo
  = $( ( !(__ Kw_DO) . )+ )


/* ---------- WHILE Statement ---------- */

WhileBlock
  = header:WhileHeader inner:InnerBlocks EndLine {
      return {
        type: "while",
        condition: header.condition,
        blocks: inner
      };
    }

WhileHeader
  = MdZIndent
    Kw_WHILE __ condition:ExprUntilDo __ Kw_DO
    Newline {
      return { condition: condition.trim() };
    }


/* ---------- IF Statement ---------- */

IfBlock
  = header:IfHeader thenBlocks:IfThenBlocks elseBlocks:ElseBlock? EndLine {
      return {
        type: "if",
        condition: header.condition,
        then: thenBlocks,
        ...(elseBlocks ? { else: elseBlocks } : {})
      };
    }

IfHeader
  = MdZIndent
    Kw_IF __ condition:IfCondition __ Kw_THEN
    Newline {
      return { condition };
    }

IfThenBlocks
  = blocks:IfThenBlock* { return blocks; }

IfThenBlock
  = &NotEndOrElse innerBlock:(
    ForBlock /
    WhileBlock /
    IfBlock /
    DoBlock /
    PushLine /
    AssignLine /
    StatementLine /
    HostInnerBlock
  ) {
    return innerBlock;
  }

ElseBlock
  = ElseLine inner:InnerBlocks { return inner; }


/* ---------- DO Statement ---------- */

DoBlock
  = header:DoHeader inner:DoInnerBlocks EndLine {
      return {
        type: "do",
        blocks: inner
      };
    }

DoHeader
  = MdZIndent Kw_DO LineEnd

DoInnerBlocks
  = blocks:DoInnerBlock* {
      return blocks.filter((block) => block !== null);
    }

DoInnerBlock
  = &NotEnd innerBlock:(
    ForBlock /
    WhileBlock /
    IfBlock /
    DoBlock /
    DelegateBlock /
    UseBlock /
    PushLine /
    AssignLine /
    StatementLine /
    DoHostLine
  ) {
    return innerBlock;
  }

DoHostLine
  = !BlockStartLine
    !PushStartLine
    !AssignStartLine
    !StatementStartLine
    !EndLine
    indent:$(Indent) ListMarker?
    line:LineText?
    Newline {
      const text = indent + (line ?? "") + "\n";
      if (text.trim() === "") return null;
      return { type: "host", text };
    }


/* ---------- IF Expressions ---------- */

IfCondition = OrExpr

OrExpr
  = left:AndExpr tail:(_ Kw_OR _ AndExpr)* {
      return tail.reduce((acc, [, , , right]) => ({
        type: "binary",
        op: "OR",
        left: acc,
        right
      }), left);
    }

AndExpr
  = left:NotExpr tail:(_ Kw_AND _ NotExpr)* {
      return tail.reduce((acc, [, , , right]) => ({
        type: "binary",
        op: "AND",
        left: acc,
        right
      }), left);
    }

NotExpr
  = Kw_NOT __ expr:NotExpr {
      return { type: "not", expression: expr };
    }
  / ComparisonExpr

ComparisonExpr
  = left:ExprText _ op:CompOp _ right:ExprText {
      return {
        type: "comparison",
        op,
        left: left.trim(),
        right: right.trim()
      };
    }
  / expr:ExprText {
      return expr.trim();
    }

CompOp = "!=" / "="

ExprText
  = $( ( !(_ CompOp) !(__ Kw_AND) !(__ Kw_OR) !(__ Kw_THEN) . )+ )


/* ---------- USE / DELEGATE Statements ---------- */

DelegateBlock
  = header:DelegateHeader details:StatementDetails? {
      const toText = details?.to ? ` TO ${details.to}` : "";
      const text = `${header.text}${toText}`.trim();
      const out = {
        type: "stmt",
        keyword: "DELEGATE",
        text
      };
      if (header.modifier) out.modifier = header.modifier;
      if (details?.with) out.with = details.with;
      return out;
    }

UseBlock
  = header:UseHeader details:StatementDetails? {
      const toText = details?.to ? ` TO ${details.to}` : "";
      const text = `${header.text}${toText}`.trim();
      const out = {
        type: "stmt",
        keyword: "USE",
        text
      };
      if (details?.with && Array.isArray(details.with)) out.params = details.with;
      return out;
    }

DelegateHeader
  = MdZIndent modifier:(Kw_ASYNC / Kw_AWAIT) __ Kw_DELEGATE __ text:LineText? LineEnd {
      return { modifier, text: (text ?? "").trim() };
    }
  / MdZIndent Kw_DELEGATE __ text:LineText? LineEnd {
      return { modifier: null, text: (text ?? "").trim() };
    }

UseHeader
  = MdZIndent Kw_USE __ text:LineText? LineEnd {
      return { text: (text ?? "").trim() };
    }

StatementDetails
  = to:ToLine? withBlock:WithBlock? {
      return { to, with: withBlock };
    }

DetailIndent = Indent ListMarker

ToLine
  = DetailIndent Kw_TO __ text:LineText? LineEnd {
      return (text ?? "").trim();
    }

WithBlock
  = WithAnchor
  / WithParams

WithAnchor
  = DetailIndent Kw_WITH __ "#" name:AnchorName LineEnd {
      return { type: "anchor", name };
    }

WithParams
  = DetailIndent Kw_WITH LineEnd params:WithParamLine+ {
      return params;
    }

WithParamLine
  = Indent ListMarker name:ParamName _ ":" _ value:LineText? LineEnd {
      return { name: name.trim(), value: (value ?? "").trim() };
    }

AnchorName = $( [a-zA-Z_][a-zA-Z0-9_-]* )
ParamName = $( (!":" .)+ )


/* ---------- Host blocks ---------- */

HostBlock
  = lines:HostLineTop+ {
      const text = lines.join("");
      if (text.trim() === "") return null;
      return { type: "host", text };
    }

HostInnerBlock
  = lines:HostLineInner+ {
      const text = lines.join("");
      if (text.trim() === "") return null;
      return { type: "host", text };
    }

HostLineTop
  = !BlockStartLine
  	!PushStartLine
  	!AssignStartLine
  	!StatementStartLine
    !EndLine
    s:LineText?
    Newline {
    	return (s ?? "") + "\n";
}

HostLineInner
  = !BlockStartLine
    !PushStartLine
    !AssignStartLine
    !StatementStartLine
    !EndLine
    indent:$(Indent ListMarker?)
    line:LineText?
    Newline {
      return indent + (line ?? "") + "\n";
    }

HostTail
  = !BlockStartLine
    !PushStartLine
    !AssignStartLine
    !StatementStartLine
    !EndLine
    line:LineTextNonEmpty
    End {
      if (line.trim() === "") return null;
      return { type: "host", text: line };
    }


/* ---------- Push ---------- */

PushLine
  = MdZIndent target:Var _ "<<" _ value:LineText? LineEnd {
      return {
        type: "push",
        target,
        value: (value ?? "").trim()
      };
    }

PushStartLine
  = MdZIndent Var _ "<<"


/* ---------- Assignments ---------- */

AssignLine
  = AssignLineWithValue
  / AssignLineTypeOnly

AssignLineWithValue
  = MdZIndent target:Var _ typeAnn:TypeAnnotation? _ "=" _ value:Value? LineEnd {
      return {
        type: "assign",
        target,
        ...(typeAnn ? { annotatedType: typeAnn } : {}),
        value: value ?? ""
      };
    }

AssignLineTypeOnly
  = MdZIndent target:Var _ typeAnn:TypeAnnotation LineEnd {
      return {
        type: "assign",
        target,
        annotatedType: typeAnn
      };
    }

AssignStartLine
  = MdZIndent Var _ (":" / "=")

TypeAnnotation
  = ":" _ typeValue:TypeValue {
      return typeValue;
    }

TypeExprUntilEq
  = $( ( !(_ "=") !Newline . )+ )

TypeValue
  = TypeTuple
  / TypeEnum
  / typeText:TypeExprUntilEq { return typeText.trim(); }

TypeTuple
  = "(" _ elements:TypeElements? _ ")" {
      return { type: "tuple", elements: elements ?? [] };
    }

TypeElements
  = head:TypeElement tail:(_ "," _ TypeElement)* {
      return [head, ...tail.map(([, , , element]) => element)];
    }

TypeElement
  = text:$( (!("," / ")") .)+ ) { return text.trim(); }

TypeEnum
  = head:TypeEnumVariant tail:(_ "|" _ TypeEnumVariant)+ {
      return { type: "enum", variants: [head, ...tail.map(([, , , variant]) => variant)] };
    }

TypeEnumVariant
  = text:$( (!("|" / Newline / End) .)+ ) { return text.trim(); }

Value
  = ArrayLiteral
  / InferredValue
  / TemplateLiteral
  / LambdaValue
  / valueText:LineText { return valueText.trim(); }

ArrayLiteral
  = "[" _ elements:ArrayElements? _ "]" {
      return { type: "array", elements: elements ?? [] };
    }

ArrayElements
  = head:ArrayElement tail:(_ "," _ ArrayElement)* {
      return [head, ...tail.map(([, , , element]) => element)];
    }

ArrayElement
  = text:$( (!("," / "]") .)+ ) {
      return text.trim();
    }

InferredValue
  = "$/" text:$( (!"/" .)* ) "/" {
      return { type: "inferred", text };
    }

TemplateLiteral
  = "`" parts:TemplateParts "`" {
      return { type: "template", parts };
    }

TemplateParts
  = parts:TemplatePart* { return parts; }

TemplatePart
  = TemplateExpr
  / TemplateText

TemplateExpr
  = "${" name:Var "}" {
      return { type: "var", name };
    }

TemplateText
  = text:$( (!("`" / "${") .)+ ) {
      return text;
    }

LambdaValue
  = params:LambdaParams _ "=>" _ body:LineText? {
      return {
        type: "lambda",
        params,
        body: (body ?? "").trim()
      };
    }

LambdaParams
  = LambdaParamList
  / param:Var { return [param]; }

LambdaParamList
  = "(" _ head:Var tail:(_ "," _ Var)* _ ")" {
      return [head, ...tail.map(([, , , param]) => param)];
    }


/* ---------- Keywords ---------- */

Kw_FOR       = "FOR" WordBoundary { return "FOR" }
Kw_IN        = "IN" WordBoundary { return "IN" }
Kw_WHILE     = "WHILE" WordBoundary { return "WHILE" }
Kw_DO        = "DO" WordBoundary { return "DO" }
Kw_IF        = "IF" WordBoundary { return "IF" }
Kw_THEN      = "THEN" WordBoundary { return "THEN" }
Kw_ELSE      = "ELSE" WordBoundary { return "ELSE" }
Kw_AND       = "AND" WordBoundary { return "AND" }
Kw_OR        = "OR" WordBoundary { return "OR" }
Kw_NOT       = "NOT" WordBoundary { return "NOT" }
Kw_WITH      = "WITH" WordBoundary { return "WITH" }
Kw_BREAK     = "BREAK" WordBoundary { return "BREAK" }
Kw_CONTINUE  = "CONTINUE" WordBoundary { return "CONTINUE" }
Kw_RETURN    = "RETURN" WordBoundary { return "RETURN" }
Kw_DELEGATE  = "DELEGATE" WordBoundary { return "DELEGATE" }
Kw_TO        = "TO" WordBoundary { return "TO" }
Kw_ASYNC     = "ASYNC" WordBoundary { return "ASYNC" }
Kw_AWAIT     = "AWAIT" WordBoundary { return "AWAIT" }
Kw_USE       = "USE" WordBoundary { return "USE" }
Kw_GOTO      = "GOTO" WordBoundary { return "GOTO" }


/* ---------- Helpers ---------- */

Var = $("$" [a-zA-Z_][a-zA-Z0-9_]*)

Newline = "\r\n" / "\n"
End     = !.

WordBoundary = ![a-zA-Z0-9_-]

LineText         = $( (!Newline .)* )
LineTextNonEmpty = $( (!Newline .)+ )
LineEnd          = Newline / End

ListMarker = "-" [ \t]+
MdZIndent  = Indent ListMarker?
Indent     = [ \t]*
_          = [ \t]*
__         = [ \t]+
