{
  function trimText(value) {
    return typeof value === "string" ? value.trim() : value;
  }
}

Start = blocks:Blocks

Blocks
  = parts:TopBlock* tail:HostTail? {
      const out = parts.filter((part) => part !== null);
      if (tail !== null) out.push(tail);
      return out;
    }

TopBlock
  = ForBlock
  / WhileBlock
  / IfBlock
  / CaseBlock
  / DoBlock
  / SpawnBlock
  / UseBlock
  / TypeDeclLine
  / PushLine
  / AssignLine
  / StatementLine
  / HostBlock


/* --------- One-line Statement ------- */

StatementLine
  = MdZIndent kw:StatementKeyword rest:LineText? LineEnd {
      return {
        type: "stmt",
        keyword: kw,
        text: (rest ?? "").trim()
      };
    }

StatementStartLine
 = MdZIndent StatementKeyword

SpawnStartLine
  = MdZIndent (Kw_ASYNC / Kw_AWAIT) __ Kw_SPAWN
  / MdZIndent Kw_SPAWN

HostLineStart
  = BlockStartLine
  / PushStartLine
  / AssignStartLine
  / StatementStartLine
  / SpawnStartLine
  / TypeDeclStartLine
  / EndLine

StatementKeyword
  = Kw_BREAK
  / Kw_CONTINUE
  / Kw_RETURN
  / Kw_ASYNC
  / Kw_AWAIT
  / Kw_USE
  / Kw_GOTO
  / Kw_DO


/* ---------- Inner blocks ---------- */

InnerBlocks =
  blocks:InnerBlock* {
    return blocks.filter((block) => block !== null);
  }

InnerBlock =
  &NotEnd innerBlock:(
    ForBlock /
    WhileBlock /
    IfBlock /
    CaseBlock /
    DoBlock /
    SpawnBlock /
    UseBlock /
    TypeDeclLine /
    PushLine /
    AssignLine /
    StatementLine /
    HostInnerBlock
  ) {
    return innerBlock;
  }

NotEnd = !EndLine

NotEndOrElse = !EndLine !ElseLine

NotEndOrElseOrWhen = !EndLine !ElseLine !WhenStartLine

EndLine
  = MdZIndent "END" WordBoundary (Newline / End) {
  	return "END";
  }


/* ---------- Sigils ---------- */

BlockStartLine
  = MdZIndent (
      Kw_FOR __ /
      Kw_WHILE __ /
      Kw_IF __ /
      Kw_CASE __ /
      Kw_DO
    )

ElseLine
  = MdZIndent Kw_ELSE WordBoundary (Newline / End) {
      return "ELSE";
    }

WhenStartLine
  = MdZIndent Kw_WHEN WordBoundary


/* ---------- FOR Statement ---------- */

ForBlock
  = header:ForHeader inner:InnerBlocks EndLine {
      return {
        type: "for",
        target: header.target,
        iterable: header.iterable,
        blocks: inner
      };
    }

ForHeader
  = MdZIndent
    Kw_FOR __ target:ExprUntilIn __ Kw_IN __ iterable:ExprUntilDo __ Kw_DO
    LineEnd {
      return {
        target: target.trim(),
        iterable: iterable.trim()
      };
    }
  / MdZIndent
    Kw_FOR __ target:ExprUntilIn __ Kw_IN __ iterable:LineText?
    LineEnd {
      return {
        target: target.trim(),
        iterable: (iterable ?? "").trim()
      };
    }
  / MdZIndent
    Kw_FOR __ target:LineText?
    Newline
    MdZIndent Kw_IN __ iterable:LineText?
    Newline
    MdZIndent Kw_DO
    LineEnd {
      return {
        target: (target ?? "").trim(),
        iterable: (iterable ?? "").trim()
      };
    }
  / MdZIndent
    Kw_FOR __ target:LineText?
    Newline
    MdZIndent Kw_IN __ iterable:LineText?
    LineEnd {
      return {
        target: (target ?? "").trim(),
        iterable: (iterable ?? "").trim()
      };
    }

ExprUntilIn
  = $( ( !(__ Kw_IN) !Newline . )+ )

ExprUntilDo
  = $( ( !(__ Kw_DO) !Newline . )+ )


/* ---------- WHILE Statement ---------- */

WhileBlock
  = header:WhileHeader inner:InnerBlocks EndLine {
      return {
        type: "while",
        condition: header.condition,
        blocks: inner
      };
    }

WhileHeader
  = MdZIndent
    Kw_WHILE __ condition:ExprUntilDo __ Kw_DO
    LineEnd {
      return { condition: condition.trim() };
    }
  / MdZIndent
    Kw_WHILE __ condition:LineText?
    Newline
    MdZIndent Kw_DO
    LineEnd {
      return { condition: (condition ?? "").trim() };
    }
  / MdZIndent
    Kw_WHILE __ condition:LineText?
    LineEnd {
      return { condition: (condition ?? "").trim() };
    }


/* ---------- IF Statement ---------- */

IfBlock
  = header:IfHeader thenBlocks:IfThenBlocks elseBlocks:ElseBlock? EndLine {
      return {
        type: "if",
        condition: header.condition,
        then: thenBlocks,
        ...(elseBlocks ? { else: elseBlocks } : {})
      };
    }

IfHeader
  = MdZIndent
    Kw_IF __ condition:IfCondition If__ Kw_THEN
    LineEnd {
      return { condition };
    }
  / MdZIndent
    Kw_IF __ condition:IfCondition
    LineEnd {
      return { condition };
    }
  / MdZIndent
    Kw_IF __ condition:IfCondition If__ Kw_THEN?
    LineEnd {
      return { condition };
    }
  / MdZIndent
    Kw_IF __ condition:IfCondition
    Newline
    MdZIndent Kw_THEN
    LineEnd {
      return { condition };
    }

IfThenBlocks
  = blocks:IfThenBlock* { return blocks; }

IfThenBlock
  = &NotEndOrElse innerBlock:(
    ForBlock /
    WhileBlock /
    IfBlock /
    DoBlock /
    SpawnBlock /
    UseBlock /
    PushLine /
    AssignLine /
    StatementLine /
    HostInnerBlock
  ) {
    return innerBlock;
  }

ElseBlock
  = ElseLine inner:InnerBlocks { return inner; }


/* ---------- CASE Statement ---------- */

CaseBlock
  = header:CaseHeader whens:CaseWhen+ elseBlocks:CaseElseBlock? EndLine {
      return {
        type: "case",
        expression: header.expression,
        whens,
        ...(elseBlocks ? { else: elseBlocks } : {})
      };
    }

CaseHeader
  = MdZIndent
    Kw_CASE __ expression:LineText?
    LineEnd {
      return { expression: (expression ?? "").trim() };
    }

CaseWhen
  = header:WhenLine blocks:CaseWhenBlocks {
      return { condition: header.condition, blocks };
    }

WhenLine
  = MdZIndent Kw_WHEN __ condition:IfCondition WhenThen? LineEnd {
      return { condition };
    }

WhenThen
  = _ Kw_THEN

CaseWhenBlocks
  = blocks:CaseWhenBlock* { return blocks; }

CaseWhenBlock
  = &NotEndOrElseOrWhen innerBlock:(
    ForBlock /
    WhileBlock /
    IfBlock /
    CaseBlock /
    DoBlock /
    SpawnBlock /
    UseBlock /
    PushLine /
    AssignLine /
    StatementLine /
    HostInnerBlock
  ) {
    return innerBlock;
  }

CaseElseBlock
  = ElseLine inner:InnerBlocks { return inner; }

/* ---------- DO Statement ---------- */

DoBlock
  = header:DoHeader inner:DoInnerBlocks EndLine {
      return {
        type: "do",
        blocks: inner
      };
    }

DoHeader
  = MdZIndent Kw_DO LineEnd

DoInnerBlocks
  = blocks:DoInnerBlock* {
      return blocks.filter((block) => block !== null);
    }

DoInnerBlock
  = &NotEnd innerBlock:(
    ForBlock /
    WhileBlock /
    IfBlock /
    CaseBlock /
    DoBlock /
    SpawnBlock /
    UseBlock /
    PushLine /
    AssignLine /
    StatementLine /
    DoHostLine
  ) {
    return innerBlock;
  }

DoHostLine
  = !HostLineStart
    indent:$(Indent) ListMarker?
    line:LineText?
    Newline {
      const text = indent + (line ?? "") + "\n";
      if (text.trim() === "") return null;
      return { type: "host", text };
    }


/* ---------- IF Expressions ---------- */

IfCondition = IfOrExpr

IfOrExpr
  = left:IfAndExpr tail:(If_ Kw_OR If_ IfAndExpr)* {
      return tail.reduce((acc, [, , , right]) => ({
        type: "binary",
        op: "OR",
        left: acc,
        right
      }), left);
    }

IfAndExpr
  = left:IfNotExpr tail:(If_ Kw_AND If_ IfNotExpr)* {
      return tail.reduce((acc, [, , , right]) => ({
        type: "binary",
        op: "AND",
        left: acc,
        right
      }), left);
    }

IfNotExpr
  = Kw_NOT If__ expr:IfNotExpr {
      return { type: "not", expression: expr };
    }
  / IfComparisonExpr

IfComparisonExpr
  = left:IfExprText If_ op:CompOp If_ right:IfExprText {
      return {
        type: "comparison",
        op,
        left: left.trim(),
        right: right.trim()
      };
    }
  / expr:IfExprText {
      return expr.trim();
    }

CompOp = "!=" / "="

IfExprText
  = $( ( !IfExprTerminator !Newline . )+ )

IfExprTerminator
  = If_ CompOp
  / If__ Kw_AND
  / If__ Kw_OR
  / If__ Kw_THEN
  / If__ EndLine


/* ---------- USE / SPAWN Statements ---------- */

SpawnBlock
  = header:SpawnHeader details:StatementDetails? {
      const toValue = header.inlineTo ?? details?.to;
      const text = trimText(toValue ?? "");
      const out = {
        type: "stmt",
        keyword: "SPAWN",
        target: header.target,
        text
      };
      if (header.modifier) out.modifier = header.modifier;
      const inlineWith = header.inlineWith;
      if (inlineWith) out.with = inlineWith;
      if (!inlineWith && details?.with) out.with = details.with;
      return out;
    }

UseBlock
  = header:UseHeaderWithParams params:WithParamLine+ {
      const text = trimText(header.inlineTo);
      const out = {
        type: "stmt",
        keyword: "USE",
        target: header.target,
        params
      };
      if (text !== null && text !== undefined && text !== "") out.text = text;
      return out;
    }
  / header:UseHeader details:StatementDetails? {
      const toValue = header.inlineTo ?? details?.to;
      const text = trimText(toValue);
      const out = {
        type: "stmt",
        keyword: "USE",
        target: header.target
      };
      if (text !== null && text !== undefined && text !== "") out.text = text;
      if (details?.with && Array.isArray(details.with)) out.params = details.with;
      return out;
    }

TypeDeclLine
  = MdZIndent Kw_TYPE __ name:TypeName _ AssignEq _ value:TypeValue? LineEnd {
      return {
        type: "type",
        name,
        value: value ?? null
      };
    }

TypeDeclStartLine
  = MdZIndent Kw_TYPE __

SpawnHeader
  = MdZIndent modifier:(Kw_ASYNC / Kw_AWAIT) __ Kw_SPAWN __ target:AgentRef inline:SpawnInline LineEnd {
      return { modifier, target, ...inline };
    }
  / MdZIndent Kw_SPAWN __ target:AgentRef inline:SpawnInline LineEnd {
      return { modifier: null, target, ...inline };
    }

SpawnInline
  = _ Kw_TO __ value:InlineToValue? inlineWith:InlineWith? {
      return { inlineTo: value ?? "", inlineWith };
    }
  / _ Kw_WITH __ "#" name:AnchorName {
      return { inlineTo: null, inlineWith: { type: "link", kind: "anchor", value: `#${name}` } };
    }
  / _ Kw_WITH __ value:InlineToValue? {
      return { inlineTo: value ?? "", inlineWith: null };
    }
  / "" {
      return { inlineTo: null, inlineWith: null };
    }

AgentRef
  = link:LinkValue { return link; }
  / text:$( ( !(__ Kw_TO) !(__ Kw_WITH) !Newline . )+ ) { return text.trim(); }

InlineWith
  = _ Kw_WITH __ "#" name:AnchorName {
      return { type: "link", kind: "anchor", value: `#${name}` };
    }

InlineWithParamsStart
  = _ Kw_WITH

InlineToValue
  = AnchorValue
  / LinkValue
  / text:InlineToText { return text.trim(); }

InlineToText
  = $( ( !(__ Kw_WITH) !Newline . )+ )


UseHeader
  = MdZIndent Kw_USE __ target:UseTarget inline:UseInlineTo LineEnd {
      return { target, ...inline };
    }

UseHeaderWithParams
  = MdZIndent Kw_USE __ target:UseTarget inline:UseInlineTo InlineWithParamsStart LineEnd {
      return { target, ...inline };
    }
  / MdZIndent Kw_USE __ InlineWithParamsStart LineEnd {
      return { target: "", inlineTo: null };
    }

UseInlineTo
  = _ Kw_TO __ value:InlineToValue? {
      return { inlineTo: value ?? "" };
    }
  / "" {
      return { inlineTo: null };
    }

UseTarget
  = LinkValue
  / text:UseTargetText { return text.trim(); }

UseTargetText
  = $( ( !(__ Kw_TO) !(__ Kw_WITH) !Newline . )+ )

StatementDetails
  = to:ToLine? withBlock:WithBlock? {
      return { to, with: withBlock };
    }

DetailIndent = Indent ListMarker?

ToLine
  = DetailIndent Kw_TO __ value:InlineToValue? LineEnd {
      return value ?? "";
    }

WithBlock
  = WithAnchor
  / WithParams

WithAnchor
  = DetailIndent Kw_WITH __ "#" name:AnchorName LineEnd {
      return { type: "link", kind: "anchor", value: `#${name}` };
    }

WithParams
  = DetailIndent Kw_WITH LineEnd params:WithParamLine+ {
      return params;
    }

WithParamLine
  = Indent ListMarker? name:ParamName _ ":" _ value:LineText? LineEnd {
      return { name: name.trim(), value: (value ?? "").trim() };
    }

AnchorName = $( [a-zA-Z_][a-zA-Z0-9_-]* )
ParamName = $( (!(":" / Newline) .)+ )

LinkValue
  = "~/" path:$( [a-zA-Z0-9_./-]+ ) {
      return { type: "link", kind: "path", value: `~/${path}` };
    }


/* ---------- Host blocks ---------- */

HostBlock
  = lines:HostLineTop+ {
      const text = lines.join("");
      const trimmed = text.replace(/^(?:[ \t]*\n)+/, "");
      if (trimmed.trim() === "") return null;
      return { type: "host", text: trimmed };
    }

HostInnerBlock
  = lines:HostLineInner+ {
      const text = lines.join("");
      const trimmed = text.replace(/^(?:[ \t]*\n)+/, "");
      if (trimmed.trim() === "") return null;
      return { type: "host", text: trimmed };
    }

HostLineTop
  = !HostLineStart
    s:LineText?
    Newline {
      const line = s ?? "";
    	return line + "\n";
}

HostLineInner
  = !HostLineStart
    indent:$(Indent ListMarker?)
    line:LineText?
    Newline {
      const text = (line ?? "");
      return indent + text + "\n";
    }

HostTail
  = !HostLineStart
    line:LineTextNonEmpty
    End {
      if (line.trim() === "") return null;
      return { type: "host", text: line };
    }


/* ---------- Push ---------- */

PushLine
  = MdZIndent target:Var _ "<<" _ value:LineText? LineEnd {
      return {
        type: "push",
        target,
        value: (value ?? "").trim()
      };
    }

PushStartLine
  = MdZIndent Var _ "<<"


/* ---------- Assignments ---------- */

AssignLine
  = AssignLineWithValue
  / AssignLineTypeOnly

AssignLineWithValue
  = MdZIndent target:Var _ typeAnn:TypeAnnotation? _ AssignEq _ value:Value? LineEnd {
      return {
        type: "assign",
        target,
        ...(typeAnn ? { annotatedType: typeAnn } : {}),
        value: value ?? ""
      };
    }

AssignLineTypeOnly
  = MdZIndent target:Var _ typeAnn:TypeAnnotation LineEnd {
      return {
        type: "assign",
        target,
        annotatedType: typeAnn
      };
    }

AssignStartLine
  = MdZIndent Var _ (":" / AssignEq)

TypeAnnotation
  = ":" _ typeValue:TypeValue {
      return typeValue;
    }

TypeValue
  = TypeTuple
  / TypeEnum
  / TypeLiteral
  / TypeRef
  / TypeSemantic

TypeTuple
  = "(" _ elements:TypeElements? _ ")" !(_ "=>") {
      return { type: "tuple", elements: elements ?? [] };
    }

TypeElements
  = head:TypeElement tail:(_ "," _ TypeElement)* {
      return [head, ...tail.map(([, , , element]) => element)];
    }

TypeElement
  = TypeValue

TypeEnum
  = head:TypeEnumVariant tail:(_ "|" _ TypeEnumVariant)+ {
      return { type: "enum", variants: [head, ...tail.map(([, , , variant]) => variant)] };
    }

TypeEnumVariant
  = TypeLiteral
  / TypeRef
  / TypeSemanticVariant

TypeSemantic
  = text:TypeExprUntilEq { return { type: "semantic", text: text.trim() }; }

TypeSemanticVariant
  = text:$( (!("|" / Newline / End) .)+ ) { return { type: "semantic", text: text.trim() }; }

TypeExprUntilEq
  = $( ( !(_ AssignEq) !Newline . )+ )

TypeLiteral
  = TypeLiteralNumber
  / TypeLiteralString
  / TypeLiteralLink

TypeLiteralNumber
  = num:NumberText {
      return { type: "literal", value: { type: "number", value: Number(num) } };
    }

TypeLiteralString
  = "\"" text:$( (!("\"" / "#{") .)* ) "\"" {
      return { type: "literal", value: text };
    }

TypeLiteralLink
  = link:LinkValue {
      return { type: "literal", value: link };
    }

TypeRef
  = name:TypeName args:TypeArgs? &TypeRefTerminator {
      return { type: "ref", name, ...(args ? { args } : {}) };
    }

TypeRefTerminator
  = _ ("," / ")" / ">" / "|" / AssignEq / Newline / End)

TypeName
  = $( [A-Za-z_][A-Za-z0-9_]* )

TypeArgs
  = _ "<" _ head:TypeValue tail:(_ "," _ TypeValue)* _ ">" {
      return [head, ...tail.map(([, , , value]) => value)];
    }

Value
  = ArrayLiteral
  / TupleLiteral
  / NumberValue
  / AnchorValue
  / LinkValue
  / StringLiteral
  / LambdaValue
  / PlainTextValue

PlainTextValue
  = !ValueLiteralStart valueText:LineText {
      return valueText.trim();
    }

ValueLiteralStart
  = "["
  / "("
  / "#"
  / "~/"
  / "\""

AnchorValue
  = "#" name:AnchorName {
      return { type: "link", kind: "anchor", value: `#${name}` };
    }

ArrayLiteral
  = "[" _ elements:ArrayElements? _ "]" {
      return { type: "array", elements: elements ?? [] };
    }

ArrayElements
  = head:ArrayElement tail:(_ "," _ ArrayElement)* {
      return [head, ...tail.map(([, , , element]) => element)];
    }

ArrayElement
  = ArrayValue

ArrayValue
  = ArrayLiteral
  / TupleLiteral
  / ArrayNumberValue
  / AnchorValue
  / LinkValue
  / StringLiteral
  / ArrayLambdaValue
  / ArrayPlainText

ArrayPlainText
  = text:$( (!("," / "]") .)+ ) {
      return text.trim();
    }

NumberValue
  = num:NumberText {
      return { type: "number", value: Number(num) };
    }

ArrayNumberValue
  = num:NumberText {
      return { type: "number", value: Number(num) };
    }

NumberText
  = $( [+-]? [0-9]+ ("." [0-9]+)? ([eE] [+-]? [0-9]+)? )

ArrayLambdaValue
  = params:LambdaParams _ "=>" _ body:ArrayInlineText? {
      return {
        type: "lambda",
        params,
        body: (body ?? "").trim()
      };
    }

ArrayInlineText
  = $( (!("," / "]") .)+ )

TupleLiteral
  = "(" _ elements:TupleElements? _ ")" !(_ "=>") {
      return { type: "tuple", elements: elements ?? [] };
    }

TupleElements
  = head:TupleElement tail:(_ "," _ TupleElement)* {
      return [head, ...tail.map(([, , , element]) => element)];
    }

TupleElement
  = TupleValue

TupleValue
  = ArrayLiteral
  / TupleLiteral
  / NumberValue
  / AnchorValue
  / LinkValue
  / StringLiteral
  / TupleLambdaValue
  / TuplePlainTextValue

TupleLambdaValue
  = params:LambdaParams _ "=>" _ body:TupleInlineText? {
      return {
        type: "lambda",
        params,
        body: (body ?? "").trim()
      };
    }

TupleInlineText
  = $( (!("," / ")") .)+ )

TuplePlainTextValue
  = text:$( (!("," / ")") .)+ ) {
      return text.trim();
    }


StringLiteral
  = "\"" parts:StringParts "\"" {
      const hasExpr = parts.some((part) => typeof part !== "string");
      if (!hasExpr) return `"${parts.join("")}"`;
      return { type: "template", parts };
    }

StringParts
  = parts:StringPart* { return parts; }

StringPart
  = StringExpr
  / StringText

StringExpr
  = "#{" expr:StringExprText "}" {
      return { type: "expr", expression: expr.trim() };
    }

StringExprText
  = $( (!"}" .)* )

StringText
  = text:$( (!("\"" / "#{") .)+ ) {
      return text;
    }

LambdaValue
  = params:LambdaParams _ "=>" _ body:LineText? {
      return {
        type: "lambda",
        params,
        body: (body ?? "").trim()
      };
    }

LambdaParams
  = LambdaParamList
  / param:Var { return [param]; }

LambdaParamList
  = "(" _ head:Var tail:(_ "," _ Var)* _ ")" {
      return [head, ...tail.map(([, , , param]) => param)];
    }


/* ---------- Keywords ---------- */

Kw_FOR       = "FOR" WordBoundary { return "FOR" }
Kw_IN        = "IN" WordBoundary { return "IN" }
Kw_WHILE     = "WHILE" WordBoundary { return "WHILE" }
Kw_DO        = "DO" WordBoundary { return "DO" }
Kw_IF        = "IF" WordBoundary { return "IF" }
Kw_THEN      = "THEN" WordBoundary { return "THEN" }
Kw_ELSE      = "ELSE" WordBoundary { return "ELSE" }
Kw_CASE      = "CASE" WordBoundary { return "CASE" }
Kw_WHEN      = "WHEN" WordBoundary { return "WHEN" }
Kw_AND       = "AND" WordBoundary { return "AND" }
Kw_OR        = "OR" WordBoundary { return "OR" }
Kw_NOT       = "NOT" WordBoundary { return "NOT" }
Kw_WITH      = "WITH" WordBoundary { return "WITH" }
Kw_BREAK     = "BREAK" WordBoundary { return "BREAK" }
Kw_CONTINUE  = "CONTINUE" WordBoundary { return "CONTINUE" }
Kw_RETURN    = "RETURN" WordBoundary { return "RETURN" }
Kw_TO        = "TO" WordBoundary { return "TO" }
Kw_ASYNC     = "ASYNC" WordBoundary { return "ASYNC" }
Kw_AWAIT     = "AWAIT" WordBoundary { return "AWAIT" }
Kw_USE       = "USE" WordBoundary { return "USE" }
Kw_GOTO      = "GOTO" WordBoundary { return "GOTO" }
Kw_SPAWN     = "SPAWN" WordBoundary { return "SPAWN" }
Kw_TYPE      = "TYPE" WordBoundary { return "TYPE" }


/* ---------- Helpers ---------- */

AssignEq = "=" !">"

Var = $("$" [a-zA-Z_][a-zA-Z0-9_]*)

Newline = "\r\n" / "\n"
End     = !.

WordBoundary = ![a-zA-Z0-9_-]

LineText         = $( (!Newline .)* )
LineTextNonEmpty = $( (!Newline .)+ )
LineEnd          = Newline / End

ListMarker = "-" [ \t]+
MdZIndent  = Indent ListMarker?
Indent     = [ \t]*
_          = [ \t]*
__         = [ \t]+
If_        = ([ \t] / Newline)*
If__       = ([ \t] / Newline)+
